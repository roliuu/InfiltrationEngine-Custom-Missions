<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX1332EB34A958401BAF0BB0C07985BA15">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">SerializationTools</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="RBX10310E5A950C43B4B5BEDB1FBBB50F81">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">AttributeValidation</string>
				<string name="ScriptGuid">{B73A7217-9B75-4473-875C-39DF0B607B54}</string>
				<ProtectedString name="Source"><![CDATA[local AttributesMap = require(script.Parent.AttributesMap)
local PropAttributeTypes = require(script.Parent.PropAttributeTypes)

local GlobalPropAttributes = {
	GlobalVariables = { PropAttributeTypes.OPTIONAL_BOOL, nil },
	OnProp = { PropAttributeTypes.OPTIONAL_BOOL, nil },
	Index = { PropAttributeTypes.OPTIONAL_INT, nil },
	CanShatter = { PropAttributeTypes.OPTIONAL_BOOL, nil },
	ScriptMove = { PropAttributeTypes.OPTIONAL_BOOL, nil },
	Tag = { PropAttributeTypes.STRING, nil },
	TagOffset = { PropAttributeTypes.VECTOR3, nil },
	StaticTag = { PropAttributeTypes.STRING, nil },
	HasTopBarrier = { PropAttributeTypes.OPTIONAL_BOOL, nil },
	Indestructible = { PropAttributeTypes.EXPRESSION, nil },
	IsSpawned = { PropAttributeTypes.EXPRESSION, nil },
	Color0 = { PropAttributeTypes.OPTIONAL_MISSION_COLOR, nil },
	Color1 = { PropAttributeTypes.OPTIONAL_MISSION_COLOR, nil },
	Color2 = { PropAttributeTypes.OPTIONAL_MISSION_COLOR, nil },
	Color3 = { PropAttributeTypes.OPTIONAL_MISSION_COLOR, nil },
	Color4 = { PropAttributeTypes.OPTIONAL_MISSION_COLOR, nil },
	Color5 = { PropAttributeTypes.OPTIONAL_MISSION_COLOR, nil },
	Material0 = { PropAttributeTypes.OPTIONAL_MATERIAL, nil },
	Material1 = { PropAttributeTypes.OPTIONAL_MATERIAL, nil },
	Material2 = { PropAttributeTypes.OPTIONAL_MATERIAL, nil },
	Material3 = { PropAttributeTypes.OPTIONAL_MATERIAL, nil },
	Material4 = { PropAttributeTypes.OPTIONAL_MATERIAL, nil },
	Material5 = { PropAttributeTypes.OPTIONAL_MATERIAL, nil },
	Type = { PropAttributeTypes.STRING, nil },
}

local testAttributeCompatibility = function(attributeType, value, objectName, attributeName)
	if attributeType == "NUMBER" then
		if type(value) == "number" then
			return true
		else
			warn("The " .. objectName .. " object's " .. attributeName .. " attribute must contain a number type.")
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "INT" then
		if type(value) == "number" then
			if value == math.round(value) then
				return true
			else
				warn("The " .. objectName .. " object's " .. attributeName .. " attribute must be an integer.")
				warn("Found value: " .. tostring(value))
			end
		else
			warn(
				"The "
					.. objectName
					.. " object's "
					.. attributeName
					.. " attribute must contain a number type (integer)."
			)
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "EXPRESSION" then
		if type(value) == "boolean" or type(value) == "string" or type(value) == "number" then
			return true
		else
			warn(
				"The "
					.. objectName
					.. " object's "
					.. attributeName
					.. " attribute must contain a boolean, string, or number type."
			)
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "STATE_VALUE" then
		if type(value) == "string" then
			if string.find(value, "%s") == nil then
				return true
			else
				warn("The " .. objectName .. " object's " .. attributeName .. " attribute must not contain whitespace.")
				warn("Found value: " .. tostring(value))
			end
		else
			warn(
				"The "
					.. objectName
					.. " object's "
					.. attributeName
					.. " attribute must contain a string type with no whitespace."
			)
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "STRING" then
		if type(value) == "string" then
			return true
		else
			warn("The " .. objectName .. " object's " .. attributeName .. " attribute must contain a string type.")
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "NETWORK_ID" then
		if type(value) == "string" then
			local int = tonumber(value)
			if not int or int ~= math.round(int) or int < 1 or int > 999 then
				warn(
					"The "
						.. objectName
						.. " object's "
						.. attributeName
						.. " attribute must contain a number type between 1 and 999."
				)
			end
		elseif type(value) == "number" then
			if value == math.round(value) and value >= 1 and value <= 999 then
				return true
			else
				warn(
					"The "
						.. objectName
						.. " object's "
						.. attributeName
						.. " attribute must contain a number type between 1 and 999."
				)
				warn("Found value: " .. tostring(value))
			end
		else
			warn(
				"The "
					.. objectName
					.. " object's "
					.. attributeName
					.. " attribute must contain a number type between 1 and 999."
			)
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "NETWORK_ID_STRING" then
		if value == "" then
			return true
		end
		local num = tonumber(value)
		if num == math.round(num) and num >= 1 and num <= 999 then
			return true
		else
			warn(
				"The "
					.. objectName
					.. " object's "
					.. attributeName
					.. ' attribute must contain a string type of a number between 1 and 999 or be blank "".'
			)
			warn("Found value: " .. tostring(value))
		end
		return false
	elseif attributeType == "OPTIONAL_BOOL" then
		if value == nil or type(value) == "boolean" then
			return true
		else
			warn("The " .. objectName .. " object's " .. attributeName .. " attribute must be a boolean or nil.")
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "OPTIONAL_MISSION_COLOR" then
		if value == nil or typeof(value) == "Color3" or type(value) == "string" then
			return true
		else
			warn(
				"The "
					.. objectName
					.. " object's "
					.. attributeName
					.. " attribute must be a nil, Color3, or a string."
			)
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "OPTIONAL_MATERIAL" then
		if value == nil or type(value) == "string" then
			return true
		else
			warn("The " .. objectName .. " object's " .. attributeName .. " attribute must be a nil or a string.")
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "VECTOR3" then
		if typeof(value) == "Vector3" then
			return true
		else
			warn(
				"The "
					.. objectName
					.. " object's "
					.. attributeName
					.. " attribute must contain a number type (integer)."
			)
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "OPTIONAL_INT" then
		if value == nil then
			return true
		elseif type(value) == "number" then
			if value == math.round(value) then
				return true
			else
				warn("The " .. objectName .. " object's " .. attributeName .. " attribute must be nil or an integer.")
				warn("Found value: " .. tostring(value))
			end
		else
			warn(
				"The "
					.. objectName
					.. " object's "
					.. attributeName
					.. " attribute must contain a number type (integer)."
			)
			warn("Found type: " .. type(value))
		end
		return false
	elseif attributeType == "BOOL" then
		if type(value) == "boolean" then
			return true
		else
			warn("The " .. objectName .. " object's " .. attributeName .. " attribute must be a boolean")
			warn("Found type: " .. type(value))
		end
		return false
	else
		error(`Attribute type does not exist: {tostring(attributeType)}`)
	end
end

return {
	Validate = function(className, instanceName, attributes, includeDefaults)
		if className == "Folder" then
			return attributes
		end

		local name = className == "BoolValue" and attributes.Type or instanceName
		if not AttributesMap[name] then
			return attributes -- If not included in the prop list, just return the normal attributes list
		else
			local newAttributes = {}
			local attributeTypes = AttributesMap[name]
			for attName, tableOfInfo in pairs(attributeTypes) do -- add attributes specifically listed in AttributesMap.lua
				if not attributes[attName] then
					if includeDefaults then
						newAttributes[attName] = tableOfInfo[2]
					end
					continue
				end
				local givenValue = attributes[attName]
				local attributeTypeName = ""
				for i, v in pairs(PropAttributeTypes) do
					if tableOfInfo[1] == v then
						attributeTypeName = i
					end
				end
				if attributeTypeName == "" then
					error(`attribute type does not exist: {name} {attName}`)
				end
				if not testAttributeCompatibility(attributeTypeName, givenValue, name, attName) then
					if includeDefaults then
						newAttributes[attName] = attributeTypes[attName][2]
					else
						continue
					end
				end
				-- If the value isn't default or is and the includeDefaults value is set to true, then add it to the list
				if (tableOfInfo[2] == givenValue and includeDefaults) or tableOfInfo[2] ~= givenValue then
					newAttributes[attName] = givenValue
				end
			end
			for attribute, value in pairs(attributes) do -- add the remaining attributes that are defined in the global attributes table above
				if GlobalPropAttributes[attribute] then
					local tableOfInfo = GlobalPropAttributes[attribute]
					local attributeTypeName = ""
					for i, v in pairs(PropAttributeTypes) do
						if tableOfInfo[1] == v then
							attributeTypeName = i
						end
					end
					if testAttributeCompatibility(attributeTypeName, value, name, attribute) then
						newAttributes[attribute] = value
					else
						newAttributes[attribute] = nil -- set to nil if it doesn't fit properly
					end
				elseif not attributeTypes[attribute] then
					warn("Unknown attribute will be discarded:", attribute, name)
				end
			end

			return newAttributes
		end
	end,
}]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX75520294164B41989347294B3F0B543E">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">AttributesMap</string>
				<string name="ScriptGuid">{AA38C603-9F4B-4875-B71B-FF89C707F5ED}</string>
				<ProtectedString name="Source"><![CDATA[-- NOTE: Do not edit this file manually. Use PropCompiler.py.
AttributeType = require(script.Parent.PropAttributeTypes)
return {
	AccessPoint = {
		NetworkId = {AttributeType.NETWORK_ID, 1},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		TriggerInvestigation = {AttributeType.EXPRESSION, true},
	},
	AmmoBox = {
	},
	BadgeReader = {
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		CustomBadges = {AttributeType.STRING, ""},
		UseITBadge = {AttributeType.BOOL, false},
		UseLeadSecurityBadge = {AttributeType.BOOL, false},
		UseSecurityBadge = {AttributeType.BOOL, false},
	},
	BarredWindow = {
		GlassMaterial = {AttributeType.STRING, "SmoothPlastic"},
		GlassTransparency = {AttributeType.NUMBER, 0.8},
		HorizontalSpacing = {AttributeType.NUMBER, 2},
		VerticalSpacing = {AttributeType.NUMBER, 2},
	},
	BoxStack2 = {
	},
	CandlePlate = {
	},
	CardboardBox = {
	},
	CardReader = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		ValidCards = {AttributeType.STRING, ""},
		MinimumCard = {AttributeType.STRING, ""},
		LightLevel = {AttributeType.INT, 1},
		Blocked = {AttributeType.EXPRESSION, ""},
	},
	ClimbablePipe = {
	},
	ClothingRack = {
		UsedVariable = {AttributeType.STATE_VALUE, ""},
	},
	CodeCardReader = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		ValidCards = {AttributeType.STRING, ""},
		CodeVariable = {AttributeType.STATE_VALUE, ""},
		CodeRevealedVariable = {AttributeType.STATE_VALUE, ""},
		WrongCodeVariable = {AttributeType.STATE_VALUE, ""},
		CodeSeed = {AttributeType.INT, 1},
		PromptText = {AttributeType.STRING, ""},
		MinimumCard = {AttributeType.STRING, ""},
		ReaderEnabled = {AttributeType.EXPRESSION, "1"},
		AltPromptActive = {AttributeType.EXPRESSION, ""},
		AltPromptSwitchTime = {AttributeType.NUMBER, 1},
	},
	CodeKeypad = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		CodeRevealedVariable = {AttributeType.STATE_VALUE, ""},
		PromptText = {AttributeType.STRING, ""},
		WrongCodeVariable = {AttributeType.STATE_VALUE, ""},
		ReadoutText = {AttributeType.EXPRESSION, ""},
		RewireTime = {AttributeType.NUMBER, 12},
		PromptSubtitle = {AttributeType.STRING, ""},
		KeypadEnabled = {AttributeType.EXPRESSION, "1"},
		NoiseEnabled = {AttributeType.EXPRESSION, ""},
		CodeVariable = {AttributeType.STATE_VALUE, ""},
		CodeSeed = {AttributeType.INT, 1},
	},
	CombatCuttableFence = {
	},
	DecorativePipe = {
		RingSpace = {AttributeType.NUMBER, 8},
		Corner = {AttributeType.BOOL, false},
		BendTop = {AttributeType.BOOL, false},
	},
	DecorativeVent = {
		BendBottom = {AttributeType.INT, 0},
		BendTop = {AttributeType.INT, 0},
		RingSpace = {AttributeType.NUMBER, 8},
		RingDepth = {AttributeType.NUMBER, 0},
	},
	DepositBox1 = {
		TiltItem = {AttributeType.NUMBER, 0},
		RotateItem = {AttributeType.NUMBER, 0},
		Item = {AttributeType.STRING, ""},
		ItemTagString = {AttributeType.STRING, ""},
		KeyItem = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		IncludeSidePart = {AttributeType.BOOL, true},
		BoxNumber = {AttributeType.INT, 1},
	},
	DepositBox2 = {
		TiltItem = {AttributeType.NUMBER, 0},
		RotateItem = {AttributeType.NUMBER, 0},
		Item = {AttributeType.STRING, ""},
		ItemTagString = {AttributeType.STRING, ""},
		KeyItem = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		IncludeSidePart = {AttributeType.BOOL, true},
		BoxNumber = {AttributeType.INT, 1},
	},
	DepositBox3 = {
		TiltItem = {AttributeType.NUMBER, 0},
		RotateItem = {AttributeType.NUMBER, 0},
		Item = {AttributeType.STRING, ""},
		ItemTagString = {AttributeType.STRING, ""},
		KeyItem = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		IncludeSidePart = {AttributeType.BOOL, true},
		BoxNumber = {AttributeType.INT, 1},
	},
	DeskPhoneCallable = {
		CallAcceptedVariable = {AttributeType.STATE_VALUE, ""},
		CallIgnoredVariable = {AttributeType.STATE_VALUE, ""},
		IsCalling = {AttributeType.EXPRESSION, ""},
		CallTime = {AttributeType.INT, 15},
	},
	DeskSafe = {
		ItemTagString = {AttributeType.STRING, ""},
		Item = {AttributeType.STRING, ""},
	},
	DisguiseTrigger = {
		UsedVariable = {AttributeType.STATE_VALUE, ""},
		Disguise = {AttributeType.STRING, ""},
	},
	DomeCamera = {
		AngleMax = {AttributeType.STRING, "0"},
		AngleMin = {AttributeType.STRING, "0"},
		Exterior = {AttributeType.BOOL, true},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		NetworkDestination = {AttributeType.NETWORK_ID_STRING, ""},
		CamSet = {AttributeType.STRING, ""},
		CameraArea = {AttributeType.STRING, ""},
		AngleDown = {AttributeType.NUMBER, 0},
		Wireless = {AttributeType.BOOL, true},
		CamNumber = {AttributeType.INT, 0},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		Angle = {AttributeType.STRING, 0},
		DetectionSpeed = {AttributeType.NUMBER, 1},
		LocationKey = {AttributeType.STRING, ""},
		MapFloorOffset = {AttributeType.INT, 0},
	},
	DoorGlass = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
	},
	DoorMetal = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
	},
	DoorMetalElectronic = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
	},
	DoorPushLeft = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
	},
	DoorWood = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
	},
	DoorWoodElectronic = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
	},
	DoubleVaultDoor = {
		OpenCondition = {AttributeType.EXPRESSION, ""},
	},
	Elevator = {
	},
	ElevatorCallButton = {
		CallVariable = {AttributeType.STATE_VALUE, ""},
		DisabledInCombat = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		PowerArea = {AttributeType.STATE_VALUE, ""},
	},
	ElevatorCardReader = {
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		DisabledInCombat = {AttributeType.BOOL, false},
	},
	EventPumpkin = {
	},
	ExplosionSource = {
	},
	FloorAccessCover = {
		CanOpen = {AttributeType.EXPRESSION, ""},
		OpenedVariable = {AttributeType.STATE_VALUE, ""},
	},
	Flowerpot = {
		Seed = {AttributeType.INT, 0},
	},
	FreestandingSafe = {
		Seed = {AttributeType.INT, 1},
		CanInteract = {AttributeType.EXPRESSION, ""},
		CodeRevealedVariable = {AttributeType.STATE_VALUE, ""},
		ExplosiveOpenedVariable = {AttributeType.STATE_VALUE, ""},
		OpenedVariable = {AttributeType.STATE_VALUE, ""},
		ItemRemovedVariable = {AttributeType.STATE_VALUE, ""},
		ItemRotationX = {AttributeType.NUMBER, 0},
		ItemRotationY = {AttributeType.NUMBER, 0},
		ItemRotationZ = {AttributeType.NUMBER, 0},
		Item = {AttributeType.STRING, ""},
		ItemTagString = {AttributeType.STRING, ""},
		KeyItem = {AttributeType.BOOL, false},
	},
	GarageDoor = {
		Height = {AttributeType.EXPRESSION, "0"},
	},
	GlassKitchenTable = {
	},
	HackableComputer = {
		MonitorOffset = {AttributeType.VECTOR3, Vector3.new(0, 0, 0)},
		MonitorAngle = {AttributeType.NUMBER, 0},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		ScreenText = {AttributeType.EXPRESSION, ""},
		DesktopTransparency = {AttributeType.NUMBER, 0},
		NetworkId = {AttributeType.NETWORK_ID, 0},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		PasswordUnlockedVariable = {AttributeType.STATE_VALUE, ""},
		NetworkNameTag = {AttributeType.STRING, ""},
		DesktopBackground = {AttributeType.STRING, ""},
		PasswordDifficulty = {AttributeType.EXPRESSION, 0},
		OldMonitor = {AttributeType.BOOL, false},
		PhysicalAccessBlocked = {AttributeType.EXPRESSION, 0},
	},
	HeavySecurityDoor = {
		ServerExplosiveFullDamageVariable = {AttributeType.STATE_VALUE, ""},
		ExplosiveNoDamageVariable = {AttributeType.STATE_VALUE, ""},
		ExplosivePartialDamageVariable = {AttributeType.STATE_VALUE, ""},
		ExplosiveFullDamageVariable = {AttributeType.STATE_VALUE, ""},
		OpenCondition = {AttributeType.EXPRESSION, ""},
	},
	Helicopter = {
		ActiveCondition = {AttributeType.EXPRESSION, ""},
		StopAttemptDialogue = {AttributeType.STRING, ""},
		StartupTime = {AttributeType.INT, 60},
		ProgressVariable = {AttributeType.STATE_VALUE, ""},
		PoliceShutdownVariable = {AttributeType.STATE_VALUE, ""},
	},
	HiddenWallSafe = {
		PromptVisible = {AttributeType.EXPRESSION, ""},
		Item = {AttributeType.STRING, ""},
		ItemTagString = {AttributeType.STRING, ""},
		CodeRevealedVariable = {AttributeType.STATE_VALUE, ""},
		OpenedVariable = {AttributeType.STATE_VALUE, ""},
		Seed = {AttributeType.INT, 1},
		ExplosiveOpenVariable = {AttributeType.STATE_VALUE, ""},
		ItemRotationX = {AttributeType.INT, 0},
		ItemRotationY = {AttributeType.INT, 0},
		ItemRotationZ = {AttributeType.INT, 0},
		Image = {AttributeType.INT, 0},
		SafeLocatedVariable = {AttributeType.STATE_VALUE, ""},
		CoverColor = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(0, 0, 0)},
		OffsetX = {AttributeType.NUMBER, 0},
		KeyItem = {AttributeType.BOOL, false},
		CoverMaterial = {AttributeType.STRING, ""},
		SafeTag = {AttributeType.STRING, ""},
		HiddenShuffleId = {AttributeType.STRING, ""},
	},
	IndustrialShelvesSmall = {
		BoxSeed = {AttributeType.INT, 0},
		BoxDensity = {AttributeType.NUMBER, 0},
		BoxColor = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(0, 0, 0)},
	},
	InteractionBlocker = {
	},
	IntroCam = {
	},
	Ladder = {
		Decorative = {AttributeType.BOOL, false},
	},
	LandscapePhotoHorizontalRectangle = {
		Image = {AttributeType.INT, 0},
	},
	LandscapePhotoSquare = {
		Image = {AttributeType.INT, 0},
	},
	LandscapePhotoVerticalThird = {
		Image = {AttributeType.INT, 0},
		OffsetX = {AttributeType.NUMBER, 0},
	},
	Laptop = {
	},
	LaptopOld = {
		DesktopBackground = {AttributeType.STRING, ""},
		PasswordUnlockedVariable = {AttributeType.STATE_VALUE, ""},
		DesktopTransparency = {AttributeType.NUMBER, 0},
		NetworkId = {AttributeType.NETWORK_ID, 1},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		PasswordLockedCondition = {AttributeType.EXPRESSION, ""},
		PasswordDifficulty = {AttributeType.EXPRESSION, 0},
		ScreenText = {AttributeType.EXPRESSION, ""},
		NetworkNameTag = {AttributeType.STRING, ""},
	},
	LaundryBasket = {
		UsedVariable = {AttributeType.STATE_VALUE, ""},
		Disguise = {AttributeType.STRING, ""},
	},
	LeverageMove = {
		MoveDist = {AttributeType.EXPRESSION, 0},
		Prop = {AttributeType.STRING, ""},
		MovedToEndVariable = {AttributeType.STATE_VALUE, ""},
		VisibleCondition = {AttributeType.EXPRESSION, "1"},
		Heavy = {AttributeType.BOOL, true},
	},
	LongCoffeeTable = {
	},
	LootCash = {
		ItemTagString = {AttributeType.STRING, ""},
	},
	LootCash2 = {
		ItemTagString = {AttributeType.STRING, ""},
	},
	LootThermite = {
		ItemTagString = {AttributeType.STATE_VALUE, ""},
	},
	LootWeapons = {
		ItemTagString = {AttributeType.STRING, ""},
	},
	LowVent = {
		Blocked = {AttributeType.EXPRESSION, ""},
	},
	MetalDetector = {
		PowerLevel = {AttributeType.EXPRESSION, ""},
	},
	MinimapBlock = {
	},
	Monitor = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		ScreenText = {AttributeType.EXPRESSION, ""},
		DesktopTransparency = {AttributeType.NUMBER, 0},
		DesktopBackground = {AttributeType.STRING, ""},
	},
	NetworkSwitch = {
		NetworkId = {AttributeType.NETWORK_ID, 1},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		TriggerInvestigation = {AttributeType.EXPRESSION, true},
	},
	NoDropZone = {
	},
	OldMonitor = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		ScreenText = {AttributeType.EXPRESSION, ""},
		DesktopTransparency = {AttributeType.NUMBER, 0},
		DesktopBackground = {AttributeType.STRING, ""},
	},
	PowerBoxLarge = {
		TagWhileActive = {AttributeType.BOOL, false},
		AllowDisabling = {AttributeType.EXPRESSION, "1"},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		CombatDisableTarget = {AttributeType.EXPRESSION, ""},
		NoPropDamage = {AttributeType.EXPRESSION, ""},
		AllowRestoring = {AttributeType.EXPRESSION, "1"},
	},
	PowerBoxSmall = {
		TagWhileActive = {AttributeType.BOOL, false},
		AllowDisabling = {AttributeType.EXPRESSION, "1"},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		CombatDisableTarget = {AttributeType.EXPRESSION, ""},
		NoPropDamage = {AttributeType.EXPRESSION, ""},
		AllowRestoring = {AttributeType.EXPRESSION, "1"},
		Locked = {AttributeType.BOOL, false},
		ObjectName = {AttributeType.STRING, ""},
		PowerAreaParent = {AttributeType.STATE_VALUE, ""},
	},
	PropBase = {
	},
	RadioStation = {
		SocialEngineeringLevel = {AttributeType.INT, 1},
		DistractionDisabled = {AttributeType.EXPRESSION, ""},
		DistractionActive = {AttributeType.EXPRESSION, ""},
		DistractionVariable = {AttributeType.STATE_VALUE, ""},
		DistractionDialogue = {AttributeType.STRING, ""},
		DistractionSubtitle = {AttributeType.STRING, ""},
		Enabled = {AttributeType.EXPRESSION, "1"},
	},
	ScalablePlanter = {
	},
	ScalableWallPlanter = {
		PlantWidth = {AttributeType.NUMBER, 1},
		PlantHeight = {AttributeType.NUMBER, 2},
	},
	SearchableFilingCabinets = {
		FilesSpawned = {AttributeType.EXPRESSION, ""},
		KeyItem = {AttributeType.BOOL, false},
		ItemRemovedVariable = {AttributeType.STATE_VALUE, ""},
		ItemTagString = {AttributeType.STRING, ""},
	},
	SecurityCamera = {
		AngleMax = {AttributeType.STRING, "0"},
		AngleMin = {AttributeType.STRING, "0"},
		Exterior = {AttributeType.BOOL, true},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		NetworkDestination = {AttributeType.NETWORK_ID_STRING, ""},
		CamSet = {AttributeType.STRING, ""},
		CameraArea = {AttributeType.STRING, ""},
		AngleDown = {AttributeType.NUMBER, 0},
		Wireless = {AttributeType.BOOL, true},
		CamNumber = {AttributeType.INT, 0},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		Angle = {AttributeType.STRING, 0},
		DetectionSpeed = {AttributeType.NUMBER, 1},
		LocationKey = {AttributeType.STRING, ""},
		MapFloorOffset = {AttributeType.INT, 0},
	},
	ServerRack = {
	},
	ServerRackWideTerminal = {
		NetworkId = {AttributeType.NETWORK_ID, 1},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		Disconnected = {AttributeType.EXPRESSION, ""},
		DesktopTransparency = {AttributeType.NUMBER, 0},
		DesktopBackground = {AttributeType.STRING, ""},
		UseOldMonitor = {AttributeType.OPTIONAL_BOOL, false},
		ScreenText = {AttributeType.EXPRESSION, ""},
		NetworkNameTag = {AttributeType.STRING, ""},
		PasswordDifficulty = {AttributeType.EXPRESSION, ""},
		PasswordUnlockedVariable = {AttributeType.STATE_VALUE, ""},
		PasswordLockedCondition = {AttributeType.EXPRESSION, ""},
		ManualPasswordVariable = {AttributeType.STATE_VALUE, ""},
		ManualPasswordList = {AttributeType.STRING, ""},
		ManualPasswordRevealed = {AttributeType.EXPRESSION, ""},
		SecurityKeyNeeded = {AttributeType.EXPRESSION, ""},
		SecurityKeyInsertedVariable = {AttributeType.STATE_VALUE, ""},
	},
	StaticAmmoBox = {
	},
	SurfaceText = {
		TextKey = {AttributeType.STRING, ""},
		Font = {AttributeType.STRING, ""},
		HorizontalAlignment = {AttributeType.INT, 2},
	},
	TableGlass = {
	},
	TableGlassLarge = {
	},
	ThermiteBurn = {
		ProgressVariable = {AttributeType.STATE_VALUE, ""},
		StartedVariable = {AttributeType.STATE_VALUE, ""},
		BurnTime = {AttributeType.INT, 90},
	},
	ThinBush = {
	},
	TimelockCodePanel = {
		GlobalCountdownState = {AttributeType.STATE_VALUE, ""},
		CompletedVariable = {AttributeType.STATE_VALUE, ""},
		TimelockEnabled = {AttributeType.EXPRESSION, ""},
		SetState = {AttributeType.STATE_VALUE, ""},
		CountTime = {AttributeType.NUMBER, 60},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		SetValue = {AttributeType.EXPRESSION, ""},
	},
	TrespassZoneDisplay = {
		Enabled = {AttributeType.BOOL, true},
	},
	TriggerLocalChat = {
		Id = {AttributeType.STRING, ""},
		Variable = {AttributeType.STATE_VALUE, ""},
		Active = {AttributeType.EXPRESSION, ""},
	},
	TriggerVision = {
		Hold = {AttributeType.NUMBER, 0},
		Dist = {AttributeType.NUMBER, 40},
		ZoneSize = {AttributeType.NUMBER, 0.8},
		Active = {AttributeType.EXPRESSION, ""},
		Variable = {AttributeType.STATE_VALUE, ""},
	},
	TriggerZone = {
		IsGlobal = {AttributeType.BOOL, false},
		IsLocal = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		Variable = {AttributeType.STATE_VALUE, ""},
		HighlightZone = {AttributeType.BOOL, false},
	},
	TutorialText = {
	},
	VaultOpenRight = {
		OpenCondition = {AttributeType.EXPRESSION, ""},
	},
	WallSafe = {
	},
	Window = {
		Bulletproof = {AttributeType.EXPRESSION, false},
		StateValue = {AttributeType.STATE_VALUE, ""},
		GlassColor = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(0, 0, 0)},
	},
	WindowClimb = {
		Blocked = {AttributeType.EXPRESSION, ""},
		Vertical = {AttributeType.BOOL, false},
	},
	WoodChair = {
	},
	WoodShootingTarget = {
	},
	WoodTargetWithSensor = {
	},
	LandscapePhotoIds = {
	},
	AccessRequestNode = {
		ServerCondition = {AttributeType.EXPRESSION, ""},
		Dialogue = {AttributeType.STRING, ""},
		ToolRequired = {AttributeType.STRING, ""},
		AccessVariable = {AttributeType.STATE_VALUE, ""},
		SocialEngineeringLevel = {AttributeType.INT, 0},
		BotServerTag = {AttributeType.STRING, ""},
		AccessOnceVariable = {AttributeType.STATE_VALUE, ""},
		AccessTime = {AttributeType.NUMBER, 1},
	},
	AlarmButton = {
	},
	ArmoredTruck = {
	},
	BiometricLock = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		UsedVariable = {AttributeType.STATE_VALUE, ""},
		BotServerTag = {AttributeType.STRING, ""},
	},
	Cabinet = {
	},
	ConditionalHighJumpRequired = {
		Climber3Condition = {AttributeType.EXPRESSION, 1},
		Color = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(0, 0, 0)},
		Material = {AttributeType.STRING, "Plastic"},
	},
	CustomMissionLoadPoint = {
	},
	CustomReportPoint = {
		Hidden = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		CameraOnly = {AttributeType.BOOL, false},
		AutoAlertBotTag = {AttributeType.STRING, ""},
		Visibility = {AttributeType.NUMBER, 1},
		RaiseAlert = {AttributeType.INT, 1},
		MinAlert = {AttributeType.INT, 1},
		MaxAlert = {AttributeType.INT, 3},
		NotificationMessage = {AttributeType.STRING, ""},
		ReportDialogue = {AttributeType.STRING, ""},
	},
	DebugSpawnLocation = {
		Active = {AttributeType.BOOL, false},
	},
	DynamicNode = {
		Id = {AttributeType.STRING, ""},
		TakedownImmunity = {AttributeType.BOOL, false},
	},
	ElevatorFunctional = {
		OpenCondition = {AttributeType.EXPRESSION, ""},
		PlayerInElevatorVariable = {AttributeType.STATE_VALUE, ""},
		BotInElevator = {AttributeType.STATE_VALUE, ""},
		UsedVariable = {AttributeType.STATE_VALUE, ""},
		LinkedElevator = {AttributeType.STRING, ""},
		NoUsing = {AttributeType.BOOL, false},
		NoDropBlocking = {AttributeType.BOOL, false},
		WarpTargetId = {AttributeType.STRING, ""},
		WarpPointId = {AttributeType.STRING, ""},
	},
	EscapeZone = {
	},
	FlowStart = {
	},
	FreeTrigger = {
		TitleKey = {AttributeType.STRING, ""},
		SubtitleKey = {AttributeType.STRING, ""},
		DisabledSubtitle = {AttributeType.STRING, ""},
		ServerVisible = {AttributeType.EXPRESSION, ""},
		ClientVisible = {AttributeType.EXPRESSION, ""},
		ServerEnabled = {AttributeType.EXPRESSION, ""},
		HoldTime = {AttributeType.NUMBER, 0.5},
		HoldAlert = {AttributeType.EXPRESSION, ""},
		SaveProgress = {AttributeType.BOOL, false},
		Tool = {AttributeType.STRING, ""},
		LinkToProp = {AttributeType.BOOL, false},
		HiddenShuffleId = {AttributeType.STRING, ""},
		SetVariable = {AttributeType.STATE_VALUE, ""},
		SetClientVariable = {AttributeType.STATE_VALUE, ""},
		TagWhileVisible = {AttributeType.BOOL, false},
		Debug = {AttributeType.BOOL, false},
		IncrementClientVariable = {AttributeType.STATE_VALUE, ""},
		OmniDir = {AttributeType.BOOL, false},
	},
	GuardCombatNode = {
	},
	init = {
	},
	IntercomCode = {
	},
	InvestigationStandTrigger = {
		ActiveCondition = {AttributeType.EXPRESSION, ""},
		HighPriority = {AttributeType.BOOL, false},
		BotServerTag = {AttributeType.STRING, ""},
		ArrivalVariableDelay = {AttributeType.NUMBER, 0},
		ArrivalVariable = {AttributeType.STATE_VALUE, ""},
		Anim = {AttributeType.STRING, ""},
		Timeout = {AttributeType.NUMBER, 0},
		CallDialogue = {AttributeType.STRING, ""},
	},
	InvestigationTrigger = {
	},
	ItemDeposit = {
		SubtitleKey = {AttributeType.STRING, ""},
		DepositedVariable = {AttributeType.STATE_VALUE, ""},
		ItemTagForDeposit = {AttributeType.STRING, ""},
		ServerVisible = {AttributeType.EXPRESSION, ""},
		TitleKey = {AttributeType.STRING, ""},
		ClientVisible = {AttributeType.STATE_VALUE, ""},
	},
	ItemSpawn = {
		Item = {AttributeType.STRING, ""},
		ItemTagString = {AttributeType.STRING, ""},
		ModelHidden = {AttributeType.BOOL, false},
		FlatTrigger = {AttributeType.BOOL, false},
		InitialPickupTime = {AttributeType.NUMBER, 0},
		PickupCondition = {AttributeType.EXPRESSION, ""},
		KeyItem = {AttributeType.BOOL, false},
		ItemRemovedVariable = {AttributeType.STATE_VALUE, ""},
		IsSpawned = {AttributeType.EXPRESSION, ""},
	},
	KillZone = {
		BotServerTag = {AttributeType.STRING, ""},
		KillerInZone = {AttributeType.BOOL, false},
		TargetInZone = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		KillCountVariable = {AttributeType.STATE_VALUE, ""},
	},
	LeaningCover = {
		AllowSpawning = {AttributeType.EXPRESSION, false},
		Enabled = {AttributeType.EXPRESSION, true},
		SpawnsIgnoreProximity = {AttributeType.BOOL, false},
		UseFromAdjacentRoom = {AttributeType.BOOL, false},
		HoldDoor = {AttributeType.BOOL, false},
		ReverseDoor = {AttributeType.BOOL, false},
		CoverTag = {AttributeType.STRING, ""},
		HoldPriority = {AttributeType.EXPRESSION, 0},
		LeanRight = {AttributeType.BOOL, false},
	},
	LeaveMissionPoint = {
	},
	LootGeneric = {
		ItemTagString = {AttributeType.STATE_VALUE, ""},
		BagColor = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(0, 0, 0)},
		BagType = {AttributeType.STRING, "Backpack"},
		ModelHidden = {AttributeType.BOOL, false},
		InitialPickupTime = {AttributeType.NUMBER, 0.5},
		ItemRemovedVariable = {AttributeType.STRING, ""},
		Contents = {AttributeType.STRING, ""},
	},
	MissionEndZone = {
		PlayersExitedVariable = {AttributeType.STATE_VALUE, ""},
		ItemRequired = {AttributeType.STRING, ""},
		ItemSecuredVariable = {AttributeType.STATE_VALUE, ""},
		Active = {AttributeType.EXPRESSION, ""},
		OpenForAll = {AttributeType.EXPRESSION, ""},
		HighlightZone = {AttributeType.BOOL, true},
	},
	MissionExit = {
	},
	PathfindingBlocker = {
	},
	PlaceholderProp = {
	},
	PointOfInterest = {
		Icon = {AttributeType.STRING, ""},
		IconScale = {AttributeType.NUMBER, 1},
	},
	PowerRoomProp1 = {
		PowerArea = {AttributeType.STRING, ""},
		DetectSabotage = {AttributeType.BOOL, true},
		DamagedVariable = {AttributeType.STATE_VALUE, ""},
	},
	PowerRoomProp2 = {
		PowerArea = {AttributeType.STRING, ""},
		DetectSabotage = {AttributeType.BOOL, true},
		DamagedVariable = {AttributeType.STATE_VALUE, ""},
	},
	RandomBotSpawnLocation = {
		StartingSpawnOnly = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, true},
	},
	RewireablePanel = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		RewireEnabled = {AttributeType.EXPRESSION, "1"},
		ObjectName = {AttributeType.STRING, ""},
		DifficultRewire = {AttributeType.BOOL, false},
	},
	SearchableFile = {
		TitleKey = {AttributeType.STRING, ""},
		SubtitleKey = {AttributeType.STRING, ""},
		ServerVisible = {AttributeType.EXPRESSION, ""},
		ClientVisisble = {AttributeType.EXPRESSION, ""},
		ServerEnabled = {AttributeType.EXPRESSION, ""},
		HoldTime = {AttributeType.NUMBER, 2},
		HoldAlert = {AttributeType.EXPRESSION, ""},
		DisabledTitle = {AttributeType.EXPRESSION, ""},
		DisabledSubtitle = {AttributeType.EXPRESSION, ""},
		Notification = {AttributeType.STRING, ""},
		SetVariable = {AttributeType.STATE_VALUE, ""},
	},
	ShuffleTarget = {
		ShuffleTag = {AttributeType.STRING, ""},
	},
	SoundSource = {
		SoundId = {AttributeType.INT, 0},
		Volume = {AttributeType.NUMBER, 0.5},
		Looped = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		SoundLength = {AttributeType.NUMBER, 0},
	},
	SpawnLocation = {
	},
	StandingCover = {
		AllowSpawning = {AttributeType.EXPRESSION, false},
		Enabled = {AttributeType.EXPRESSION, true},
		SpawnsIgnoreProximity = {AttributeType.BOOL, false},
		UseFromAdjacentRoom = {AttributeType.BOOL, false},
		HoldDoor = {AttributeType.BOOL, false},
		ReverseDoor = {AttributeType.BOOL, false},
		CoverTag = {AttributeType.STRING, ""},
		HoldPriority = {AttributeType.EXPRESSION, 0},
	},
	TriggerHit = {
	},
	TriggerRoom = {
		Active = {AttributeType.EXPRESSION, ""},
		PlayersInRoomVariable = {AttributeType.STATE_VALUE, ""},
		ClientInRoomVariable = {AttributeType.STATE_VALUE, ""},
	},
	TriggerRoomBot = {
		BotServerTag = {AttributeType.STRING, ""},
		ActiveCountVariable = {AttributeType.STATE_VALUE, ""},
		HostageCountVariable = {AttributeType.STATE_VALUE, ""},
		Active = {AttributeType.EXPRESSION, ""},
	},
	TriggerThreshhold = {
		PlayersBeforeThreshholdVariable = {AttributeType.STATE_VALUE, ""},
		PlayersAfterThreshholdVariable = {AttributeType.STATE_VALUE, ""},
		Active = {AttributeType.EXPRESSION, ""},
	},
	TriggerZoneBot = {
		RagdollCountVariable = {AttributeType.STATE_VALUE, ""},
		HostageCountVariable = {AttributeType.STATE_VALUE, ""},
		DeathCountVariable = {AttributeType.STATE_VALUE, ""},
		BotServerTag = {AttributeType.STRING, ""},
		Active = {AttributeType.EXPRESSION, ""},
	},
	VisionBlocker = {
	},
	WarpPoint = {
		WarpPointId = {AttributeType.STRING, ""},
		WarpTargetId = {AttributeType.STRING, ""},
		WarpOnHit = {AttributeType.EXPRESSION, ""},
		WarpKeepsOffset = {AttributeType.BOOL, true},
		WarpOnIncrement = {AttributeType.EXPRESSION, ""},
		WarpHostages = {AttributeType.BOOL, true},
	},
	AlarmedBehaviorOverride = {
		BotServerTag = {AttributeType.STRING, ""},
		CustomBehavior = {AttributeType.STRING, ""},
	},
	AlertRaiseCondition = {
		Amount = {AttributeType.INT, 1},
		MinValue = {AttributeType.INT, 1},
		MaxValue = {AttributeType.INT, 3},
		Reason = {AttributeType.STRING, ""},
		Condition = {AttributeType.EXPRESSION, ""},
	},
	BodyAltTrigger = {
		BotServerTag = {AttributeType.STRING, ""},
		HoldTime = {AttributeType.NUMBER, 1},
		TitleKey = {AttributeType.STRING, ""},
		SubtitleKey = {AttributeType.STRING, ""},
		TriggerNotification = {AttributeType.STRING, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		BotClientTag = {AttributeType.STRING, ""},
		ClientVisible = {AttributeType.EXPRESSION, "1"},
		ServerEnabled = {AttributeType.EXPRESSION, "1"},
	},
	BotAltTrigger = {
		BotClientTag = {AttributeType.STRING, ""},
		BotServerTag = {AttributeType.STRING, ""},
		ServerEnabled = {AttributeType.EXPRESSION, ""},
		AllowHostages = {AttributeType.BOOL, false},
		TriggerNotification = {AttributeType.STRING, ""},
		TriggerLocalNotification = {AttributeType.STRING, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		TitleKey = {AttributeType.STRING, ""},
		AllowPatroling = {AttributeType.BOOL, false},
		ClientVisible = {AttributeType.EXPRESSION, "1"},
		HoldTime = {AttributeType.NUMBER, 1},
		SubtitleKey = {AttributeType.STRING, ""},
	},
	BotStateTracker = {
		IncapacitationCountVariable = {AttributeType.STATE_VALUE, ""},
		HostageCountVariable = {AttributeType.STATE_VALUE, ""},
		DeathCountVariable = {AttributeType.STATE_VALUE, ""},
		FleeCountVariable = {AttributeType.STATE_VALUE, ""},
		TotalCountVariable = {AttributeType.STATE_VALUE, ""},
		BotServerTag = {AttributeType.STRING, ""},
	},
	CombatSpawner = {
		ReinforcementPool = {AttributeType.STRING, ""},
		TimeBetweenSpawns = {AttributeType.EXPRESSION, ""},
		EnemyWeapons = {AttributeType.STRING, ""},
		SpawnTags = {AttributeType.STRING, ""},
		FlowMap = {AttributeType.STRING, ""},
		SpawnSquads = {AttributeType.BOOL, false},
		EnemyType = {AttributeType.STRING, ""},
		AllowDespawn = {AttributeType.BOOL, false},
		SpawnsBlockedVariable = {AttributeType.STATE_VALUE, ""},
		Active = {AttributeType.EXPRESSION, ""},
		SpawnCap = {AttributeType.EXPRESSION, 6},
		EnemyWeaponsWave1 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave2 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave3 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave4 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave5 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave6 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave7 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave8 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave9 = {AttributeType.EXPRESSION, nil},
	},
	CombatWaveSpawner = {
	},
	ConditionalStateUpdate = {
		Watch = {AttributeType.EXPRESSION, ""},
		Condition = {AttributeType.EXPRESSION, ""},
		InactiveVariable = {AttributeType.STATE_VALUE, ""},
		ActiveVariable = {AttributeType.STATE_VALUE, ""},
	},
	ConversationGenericSocialEngineering = {
		BotServerTag = {AttributeType.STRING, ""},
		Visible = {AttributeType.EXPRESSION, ""},
		SocialEngineeringLevel = {AttributeType.INT, 0},
		Icon = {AttributeType.STRING, "ChatGeneric"},
		Text = {AttributeType.STRING, ""},
		Dialogue = {AttributeType.STRING, ""},
		SetVariable = {AttributeType.STATE_VALUE, ""},
		Notification = {AttributeType.STRING, ""},
		NotificationDelay = {AttributeType.NUMBER, 2.5},
		Disguise = {AttributeType.STRING, ""},
	},
	ConversationResponseCustomBehavior = {
		BotServerTag = {AttributeType.STATE_VALUE, ""},
		DisableReason = {AttributeType.EXPRESSION, ""},
		SocialEngineeringLevel = {AttributeType.INT, 0},
		Dialogue = {AttributeType.STRING, ""},
		CustomBehavior = {AttributeType.STRING, ""},
	},
	CoverFillSpawner = {
		CoverSearchLimit = {AttributeType.INT, 5},
		ActiveVariable = {AttributeType.STATE_VALUE, ""},
		SpawnsBlockedVariable = {AttributeType.STATE_VALUE, ""},
		FillFrequency = {AttributeType.NUMBER, 6},
		ReinforcementPool = {AttributeType.STRING, ""},
		UnitChanceHeavy = {AttributeType.NUMBER, 0.2},
		CoverTags = {AttributeType.STRING, ""},
		SpawnTags = {AttributeType.STRING, ""},
		Active = {AttributeType.EXPRESSION, "Mission_AlarmRaised"},
		SpawnCap = {AttributeType.EXPRESSION, "8"},
	},
	CustomBehaviorCondition = {
		Priority = {AttributeType.STRING, "Custom1"},
		BotServerTag = {AttributeType.STRING, ""},
		CustomBehavior = {AttributeType.STRING, ""},
		LoopApply = {AttributeType.BOOL, false},
		Condition = {AttributeType.EXPRESSION, false},
	},
	CustomConversation = {
	},
	CustomHack = {
		DeployCost = {AttributeType.INT, 20},
		DeployTime = {AttributeType.INT, 10},
		NodeId = {AttributeType.NETWORK_ID, 1},
		NameKey = {AttributeType.STRING, ""},
		SubtitleKey = {AttributeType.STRING, ""},
		DescriptionKey = {AttributeType.STRING, ""},
		BlockDeallocation = {AttributeType.BOOL, false},
		ProgressVariable = {AttributeType.STATE_VALUE, ""},
		PauseCondition = {AttributeType.EXPRESSION, ""},
		Priority = {AttributeType.INT, 0},
		Difficulty = {AttributeType.EXPRESSION, ""},
		Suspicion = {AttributeType.INT, 1},
		PrimaryHack = {AttributeType.BOOL, false},
		Visible = {AttributeType.EXPRESSION, "1"},
		DeployedVariable = {AttributeType.STATE_VALUE, ""},
		DeployedOnceVariable = {AttributeType.STATE_VALUE, ""},
		ScriptedBehavior = {AttributeType.STRING, ""},
		DisableReason = {AttributeType.EXPRESSION, ""},
		IconId = {AttributeType.EXPRESSION, 0},
	},
	DelayedStateUpdate = {
		Watch = {AttributeType.EXPRESSION, ""},
		DelayTime = {AttributeType.EXPRESSION, 5},
		SetVariable = {AttributeType.STATE_VALUE, ""},
		OnlyMatch = {AttributeType.BOOL, false},
	},
	HackableDoor = {
	},
	HackableElevator = {
		NetworkId = {AttributeType.NETWORK_ID, 1},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
	},
	HackingNodeStatus = {
		NetworkId = {AttributeType.NETWORK_ID, 1},
		DisabledVariable = {AttributeType.STATE_VALUE, ""},
		CompromisedVariable = {AttributeType.STATE_VALUE, ""},
	},
	HiddenShuffle = {
		HiddenShuffleId = {AttributeType.STRING, ""},
		FrontCount = {AttributeType.INT, 0},
		BackCount = {AttributeType.INT, 0},
		RevealCount = {AttributeType.INT, 1},
		RevealCountVariable = {AttributeType.STATE_VALUE, ""},
		FailCountVariable = {AttributeType.STATE_VALUE, ""},
		ClientFailCountVariable = {AttributeType.STATE_VALUE, ""},
		Seed = {AttributeType.INT, 1},
		RevealAllCondition = {AttributeType.EXPRESSION, ""},
	},
	ItemStateTracker = {
		GroundCountVariable = {AttributeType.STATE_VALUE, ""},
		TotalHeldCountVariable = {AttributeType.STATE_VALUE, ""},
		BotHeldCountVariable = {AttributeType.STATE_VALUE, ""},
		ClientHeldCountVariable = {AttributeType.STATE_VALUE, ""},
		ItemTag = {AttributeType.STRING, ""},
	},
	ItemSwapCondition = {
		Condition = {AttributeType.EXPRESSION, ""},
		SwapItemType = {AttributeType.STRING, ""},
		SwapItemTag = {AttributeType.STRING, ""},
		TargetItemTag = {AttributeType.STRING, ""},
	},
	LerpOperation = {
		OutputVariable = {AttributeType.STATE_VALUE, ""},
		Value0 = {AttributeType.EXPRESSION, ""},
		Value1 = {AttributeType.EXPRESSION, ""},
		Delta = {AttributeType.EXPRESSION, 0.5},
		AlwaysUpdate = {AttributeType.EXPRESSION, false},
		UpdateClock = {AttributeType.EXPRESSION, "0"},
	},
	MissionCompletionTrigger = {
		Condition = {AttributeType.EXPRESSION, ""},
		Timeout = {AttributeType.NUMBER, 1},
		CompleteVariable = {AttributeType.STATE_VALUE, ""},
	},
	NetworkRouter = {
	},
	Notification = {
		Condition = {AttributeType.EXPRESSION, ""},
		Notification = {AttributeType.STRING, ""},
	},
	RandomBotSpawner = {
		SpawningActive = {AttributeType.EXPRESSION, ""},
		SpawnTimeMin = {AttributeType.NUMBER, 4},
		SpawnTimeMax = {AttributeType.NUMBER, 10},
		Behavior = {AttributeType.STRING, ""},
		Class = {AttributeType.STRING, ""},
		CivilianHighlight = {AttributeType.BOOL, false},
		DetectionSpeed = {AttributeType.NUMBER, 1},
		NodesBreak = {AttributeType.STRING, ""},
		EnforceClass = {AttributeType.STRING, ""},
		Profile = {AttributeType.STRING, ""},
		Title = {AttributeType.STRING, ""},
		Outfit = {AttributeType.STRING, ""},
		Nodes = {AttributeType.STRING, ""},
		HostageDifficulty = {AttributeType.NUMBER, 0},
		ObjectiveHighlight = {AttributeType.BOOL, false},
		Weapon = {AttributeType.STRING, ""},
	},
	ReinforcementPool = {
		PoolName = {AttributeType.STRING, ""},
		WaveResetTimeMinimum = {AttributeType.NUMBER, 0},
		WaveStateVariable = {AttributeType.STATE_VALUE, ""},
		WaveVariable = {AttributeType.STATE_VALUE, ""},
		PoolLimit = {AttributeType.EXPRESSION, ""},
		RemainingVariable = {AttributeType.STATE_VALUE, ""},
		ActiveVariable = {AttributeType.STATE_VALUE, ""},
		WaveResetTime = {AttributeType.EXPRESSION, ""},
		WaveResetTimeDecrease = {AttributeType.NUMBER, 0},
	},
	SearchPatternCondition = {
		Condition = {AttributeType.EXPRESSION, ""},
		BotServerTag = {AttributeType.STRING, ""},
	},
	ServerChat = {
	},
	SniperSpawner = {
		Active = {AttributeType.EXPRESSION, ""},
		Nodes = {AttributeType.STRING, ""},
		InitialSpawns = {AttributeType.EXPRESSION, 0},
		RespawnRate = {AttributeType.EXPRESSION, 20},
	},
	TargetLureHack = {
	},
	TimerComponent = {
		SetVariable = {AttributeType.STATE_VALUE, ""},
		SetFormattedVariable = {AttributeType.STATE_VALUE, ""},
		StartValue = {AttributeType.EXPRESSION, 0},
		TargetValue = {AttributeType.EXPRESSION, 60},
		Increment = {AttributeType.EXPRESSION, 1},
		Offset = {AttributeType.EXPRESSION, ""},
		Enabled = {AttributeType.EXPRESSION, ""},
	},
	TrackBotsDown = {
	},
	TrackItemHeldServer = {
	},
	TrackNodeReserved = {
	},
	AutoConversationTrigger = {
		BotClientTag = {AttributeType.STRING, ""},
		Active = {AttributeType.EXPRESSION, ""},
	},
	BlackoutScreen = {
	},
	FileUITrigger = {
		Trigger = {AttributeType.EXPRESSION, ""},
		Lines = {AttributeType.STRING, ""},
	},
	GameCredits = {
	},
	HackingNodeHighlight = {
	},
	LocalChat = {
		DelayStart = {AttributeType.NUMBER, 0},
		Active = {AttributeType.EXPRESSION, ""},
		Dialogue = {AttributeType.STRING, ""},
		TriggerOnce = {AttributeType.BOOL, false},
		StealthOnly = {AttributeType.BOOL, false},
	},
	LocalStateComponents = {
	},
	LocalWeaponTracker = {
	},
	LocationCard = {
	},
	MusicController = {
		ActivePriority = {AttributeType.EXPRESSION, "1"},
		TrackId = {AttributeType.EXPRESSION, 0},
		NoLoop = {AttributeType.BOOL, false},
		Volume = {AttributeType.NUMBER, 0.5},
		MusicType = {AttributeType.STRING, Stealth},
	},
}]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBXCDC39969414D4BA88B2DC7B8DC3A31C5">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Main</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{E2C071DE-386E-4EB4-BC51-A4ECA5EF279F}</string>
				<ProtectedString name="Source"><![CDATA[local toolbar = plugin:CreateToolbar("Mission Exporter")
local ExportButton = toolbar:CreateButton("Exporter", "Exporter", "rbxassetid://86828934223336")

local Exporter = require(script.Parent.Writing.Main)
local CurrentPlugin = nil

ExportButton.Click:Connect(function()
	if CurrentPlugin ~= Exporter then
		if CurrentPlugin then
			CurrentPlugin.Clean()
		end
		CurrentPlugin = Exporter
		plugin:Activate(true)
		Exporter.Init(plugin:GetMouse())
	else
		plugin:Deactivate()
	end
end)

local function disablePlugin()
	Exporter.Clean()
	CurrentPlugin = nil
end

plugin.Unloading:Connect(disablePlugin)
plugin.Deactivation:Connect(disablePlugin)]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXD6866ED0699A4735B57A9DE7DD57B296">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">PropAttributeTypes</string>
				<string name="ScriptGuid">{ABDF9403-BC54-4D2A-87AC-7D95AE805CBD}</string>
				<ProtectedString name="Source"><![CDATA[local PropAttributeTypes

PropAttributeTypes = {
	NUMBER = 1,
	INT = 2,
	EXPRESSION = 3,
	STATE_VALUE = 4,
	STRING = 5,
	NETWORK_ID = 6,
	NETWORK_ID_STRING = 7,
	OPTIONAL_BOOL = 8,
	OPTIONAL_MISSION_COLOR = 9,
	OPTIONAL_MATERIAL = 10,
	VECTOR3 = 11,
	OPTIONAL_INT = 12,
	BOOL = 13,
}

return PropAttributeTypes]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBXCF0FC168BF3541C99B4B9F62FA4C4519">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Reading</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXF021206350054DFFBE05C16B80D0046F">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Read</string>
					<string name="ScriptGuid">{ACFB71DE-AD41-4655-859B-3D7EACFDD095}</string>
					<ProtectedString name="Source"><![CDATA[local StringConversion = require(script.Parent.Parent.StringConversion)
local InstanceTypes = require(script.Parent.Parent.Types.InstanceTypes)
local ReadInstance = require(script.Parent.ReadInstance)
local Materials = require(script.Parent.Parent.Types.Materials)
local PartTypes = require(script.Parent.Parent.Types.PartTypes)
local NormalId = require(script.Parent.Parent.Types.NormalId)
local MeshType = require(script.Parent.Parent.Types.MeshType)

local SIGNED_INT_BOUND = StringConversion.GetMaxNumber(3) / 2
local INT_BOUND = StringConversion.GetMaxNumber(4)
local BOUNDED_FLOAT_BOUND = StringConversion.GetMaxNumber(3)
local SHORT_BOUNDED_FLOAT_BOUND = StringConversion.GetMaxNumber(2)

local Read

local denormalize = function(value)
	return value * (2 * math.pi) - math.pi
end

local InstanceKeys = {}
for i, v in pairs(InstanceTypes) do
	InstanceKeys[v] = i
end

local function CreateEnumReader(enum, map)
	local ids = {}
	for i, v in map do
		ids[v] = i
	end
	return function(str, cursor)
		local num = StringConversion.StringToNumber(str, cursor, 1)
		return enum[ids[num]], cursor + 1
	end
end

Read = {
	Bool = function(str, cursor) -- returns the value read as a boolean. 1 symbol
		return string.sub(str, cursor, cursor) == "b", cursor + 1
	end,

	ShortInt = function(str, cursor) -- returns the value read as a short integer. 2 symbols
		return StringConversion.StringToNumber(str, cursor, 2), cursor + 2
	end,

	Int = function(str, cursor) -- returns the value read as an integer. 4 symbols
		return StringConversion.StringToNumber(str, cursor, 4), cursor + 4
	end,

	LongInt = function(str, cursor) -- returns the value read as an integer. 6 symbols
		return StringConversion.StringToNumber(str, cursor, 6), cursor + 6
	end,

	SignedInt = function(str, cursor) -- returns the value read as a signed integer. 3 symbols
		return StringConversion.StringToNumber(str, cursor, 3) - math.floor(SIGNED_INT_BOUND), cursor + 3
	end,

	Float = function(str, cursor) -- returns the value read as a float. 5 symbols
		local beforeDecimal, cursor = Read.SignedInt(str, cursor)
		local afterDecimal = StringConversion.StringToNumber(str, cursor, 2) / SHORT_BOUNDED_FLOAT_BOUND
		return afterDecimal + beforeDecimal, cursor + 2
	end,

	Vector3 = function(str, cursor) -- returns the value read as a Vector3. 24 symbols
		local X, cursor = Read.Float(str, cursor)
		local Y, cursor = Read.Float(str, cursor)
		local Z, cursor = Read.Float(str, cursor)
		return Vector3.new(X, Y, Z), cursor
	end,

	CFrame = function(str, cursor) -- returns the value read as a CFrame. 36 symbols
		local X, cursor = Read.Float(str, cursor)
		local Y, cursor = Read.Float(str, cursor)
		local Z, cursor = Read.Float(str, cursor)
		local rx, cursor = Read.BoundedFloat(str, cursor)
		rx = denormalize(rx)
		local ry, cursor = Read.BoundedFloat(str, cursor)
		ry = denormalize(ry)
		local rz, cursor = Read.BoundedFloat(str, cursor)
		rz = denormalize(rz)
		return CFrame.new(X, Y, Z) * CFrame.fromEulerAnglesXYZ(rx, ry, rz), cursor
	end,

	BoundedFloat = function(str, cursor) -- returns the value read as a bounded float between 0-1. 3 symbols.
		return StringConversion.StringToNumber(str, cursor, 3) / BOUNDED_FLOAT_BOUND, cursor + 3
	end,

	ShortBoundedFloat = function(str, cursor) -- returns the value read as a bounded float between 0-1. 4 symbols.
		return StringConversion.StringToNumber(str, cursor, 2) / SHORT_BOUNDED_FLOAT_BOUND, cursor + 2
	end,

	Color3 = function(str, cursor)
		local R, cursor = Read.ShortBoundedFloat(str, cursor)
		local G, cursor = Read.ShortBoundedFloat(str, cursor)
		local B, cursor = Read.ShortBoundedFloat(str, cursor)
		return Color3.new(R, G, B), cursor
	end,

	String = function(str, cursor)
		local length, cursor = Read.Int(str, cursor)
		local value = str:sub(cursor, cursor + length - 1)
		return value, cursor + length
	end,

	ColorMap = function(str, cursor)
		local colorMap = {}
		local colorMapLength
		colorMapLength, cursor = Read.ShortInt(str, cursor)
		for i = 1, colorMapLength do
			colorMap[i], cursor = Read.Color3(str, cursor)
		end
		return colorMap, cursor
	end,

	StringMap = function(str, cursor)
		local stringMap = {}
		local stringMapLength
		stringMapLength, cursor = Read.ShortInt(str, cursor)
		for i = 1, stringMapLength do
			stringMap[i], cursor = Read.String(str, cursor)
		end
		return stringMap, cursor
	end,

	Mission = function(str, cursor)
		local colorMap
		colorMap, cursor = Read.ColorMap(str, cursor)
		local stringMap
		stringMap, cursor = Read.StringMap(str, cursor)
		local mission = Read.Instance(str, cursor, colorMap, stringMap)

		-- Reading Color3s from TableMissionSetup
		local ImportedMissionSetup = game:GetService("HttpService")
			:JSONDecode(mission:FindFirstChild("TableMissionSetup").Value)

		for i, v in pairs(ImportedMissionSetup["Colors"]) do
			ImportedMissionSetup["Colors"][i] = Color3.new(v[1], v[2], v[3])
		end

		if game:GetService("RunService"):IsStudio() and not _G.Common then -- If the mission is read using the plugin, then create a MissionSetup ModuleScript
			local StringMissionSetup = mission:FindFirstChild("StringMissionSetup")
			local MissionSetup = Instance.new("ModuleScript")
			MissionSetup.Name = "MissionSetup"
			MissionSetup.Parent = mission
			MissionSetup.Source = StringMissionSetup.Value
		end

		return mission
	end,

	Instance = function(str, cursor, colorMap, stringMap)
		local InstanceId = StringConversion.StringToNumber(str, cursor, 1)
		cursor += 1
		if InstanceId ~= InstanceTypes.Nil then
			local InstanceType = InstanceKeys[InstanceId]
			local object, cursor = ReadInstance[InstanceType](str, cursor, Read, colorMap, stringMap)
			while StringConversion.StringToNumber(str, cursor, 1) ~= 0 do
				local child
				child, cursor = Read.Instance(str, cursor, colorMap, stringMap)
				if child ~= nil then
					child.Parent = object
				end
			end
			return object, cursor + 1
		else
			return nil, cursor
		end
	end,

	Material = CreateEnumReader(Enum.Material, Materials),
	PartType = CreateEnumReader(Enum.PartType, PartTypes),
	NormalId = CreateEnumReader(Enum.NormalId, NormalId),
	MeshType = CreateEnumReader(Enum.MeshType, MeshType),
}

return Read]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX17067F80537141DF81873648E5FA9DC1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ReadInstance</string>
					<string name="ScriptGuid">{724A23FE-1667-4A5B-BEFC-BCBBA2243B65}</string>
					<ProtectedString name="Source"><![CDATA[local StringConversion = require(script.Parent.Parent.StringConversion)
local InstanceProperties = require(script.Parent.Parent.Types.InstanceProperties)
local DefaultProperties = require(script.Parent.Parent.Types.DefaultProperties)
local AttributeTypes = require(script.Parent.Parent.Types.AttributeTypes)
local AttributeValidation = require(script.Parent.Parent.AttributeValidation)

local AttributeKeys = {}
for i, v in pairs(AttributeTypes) do
	AttributeKeys[v] = i
end

local WithAttributes = function(DefaultReader)
	return function(str, cursor, Read, colorMap, stringMap)
		local newInstance
		newInstance, cursor = DefaultReader(str, cursor, Read, colorMap, stringMap)
		local attributeId = StringConversion.StringToNumber(str, cursor, 1)
		cursor += 1
		while not (attributeId == 0) do
			local typeName = AttributeKeys[attributeId]
			local nameMapIndex
			nameMapIndex, cursor = Read.ShortInt(str, cursor)
			local name = stringMap[nameMapIndex]
			local value
			if typeName == "Color3" then
				local colorMapIndex
				colorMapIndex, cursor = Read.ShortInt(str, cursor)
				value = colorMap[colorMapIndex]
			elseif typeName == "String" then
				local valueMapIndex
				valueMapIndex, cursor = Read.ShortInt(str, cursor)
				value = stringMap[valueMapIndex]
			else
				value, cursor = Read[typeName](str, cursor)
			end
			newInstance:SetAttribute(name, value)
			attributeId = StringConversion.StringToNumber(str, cursor, 1)
			cursor += 1
		end
		local attributes = newInstance:GetAttributes()
		attributes = AttributeValidation.Validate(newInstance.ClassName, newInstance.Name, attributes, true)
		for i, v in pairs(attributes) do
			newInstance:SetAttribute(i, v)
		end
		return newInstance, cursor
	end
end

local ReadInstance

local CreateInstanceReader = function(instanceType, properties)
	local defaults = DefaultProperties[instanceType]

	local InstanceReader = function(str, cursor, Read, colorMap, stringMap)
		local newInstance = Instance.new(instanceType)
		if defaults then
			for k, v in defaults do
				newInstance[k] = v
			end
		end
		for i, v in pairs(properties) do -- sets all Instance properties to their default values as defined in InstanceProperties.lua
			newInstance[v[1]] = v[3]
		end
		local propertyId = StringConversion.StringToNumber(str, cursor, 1)
		cursor += 1
		while not (propertyId == 0) do
			local typeName = properties[propertyId][1]
			local valueType = properties[propertyId][2]
			if valueType == "Color3" then
				local colorMapIndex
				colorMapIndex, cursor = Read.ShortInt(str, cursor)
				newInstance[typeName] = colorMap[colorMapIndex]
			elseif valueType == "String" then
				local stringMapIndex
				stringMapIndex, cursor = Read.ShortInt(str, cursor)
				newInstance[typeName] = stringMap[stringMapIndex]
			else
				newInstance[typeName], cursor = Read[valueType](str, cursor)
			end
			propertyId = StringConversion.StringToNumber(str, cursor, 1)
			cursor += 1
		end
		return newInstance, cursor
	end
	return InstanceReader
end

local CreateProtectedInstanceReader = function(instanceType, properties)
	local defaults = DefaultProperties[instanceType]

	local InstanceReader = function(str, cursor, Read, colorMap, stringMap)
		local newProperties = {}
		if defaults then
			for k, v in defaults do
				newProperties[k] = v
			end
		end
		for i, v in pairs(properties) do -- sets all Instance properties to their default values as defined in InstanceProperties.lua
			newProperties[v[1]] = v[3]
		end
		local propertyId = StringConversion.StringToNumber(str, cursor, 1)
		cursor += 1
		while not (propertyId == 0) do
			local typeName = properties[propertyId][1]
			local valueType = properties[propertyId][2]
			if valueType == "Color3" then
				local colorMapIndex
				colorMapIndex, cursor = Read.ShortInt(str, cursor)
				newProperties[typeName] = colorMap[colorMapIndex]
			elseif valueType == "String" then
				local stringMapIndex
				stringMapIndex, cursor = Read.ShortInt(str, cursor)
				newProperties[typeName] = stringMap[stringMapIndex]
			else
				newProperties[typeName], cursor = Read[valueType](str, cursor)
			end
			propertyId = StringConversion.StringToNumber(str, cursor, 1)
			cursor += 1
		end

		local newInstance = Instance.new("Part")
		local meshId = newProperties.MeshId and newProperties.MeshId:match("%d+") or newProperties.MeshId
		newProperties.MeshId = nil
		if
			meshId
			and game.ReplicatedStorage:FindFirstChild("Assets")
			and game.ReplicatedStorage.Assets:FindFirstChild("ImportParts")
			and game.ReplicatedStorage.Assets.ImportParts:FindFirstChild(meshId)
		then
			newInstance = game.ReplicatedStorage.Assets.ImportParts[meshId]:Clone()
			for k, v in newProperties do
				newInstance[k] = v
			end
		else
			for k, v in newProperties do
				pcall(function()
					newInstance[k] = v
				end)
			end
		end

		return newInstance, cursor
	end
	return InstanceReader
end

ReadInstance = {
	Model = WithAttributes(CreateInstanceReader("Model", InstanceProperties.Model)),
	Folder = WithAttributes(CreateInstanceReader("Folder", InstanceProperties.Folder)),
	Part = WithAttributes(CreateInstanceReader("Part", InstanceProperties.Part)),
	PartNoAttributes = CreateInstanceReader("Part", InstanceProperties.Part),
	BoolValue = WithAttributes(CreateInstanceReader("BoolValue", InstanceProperties.BoolValue)),
	WedgePart = CreateInstanceReader("WedgePart", InstanceProperties.WedgePart),
	StringValue = CreateInstanceReader("StringValue", InstanceProperties.StringValue),
	MeshPart = WithAttributes(CreateProtectedInstanceReader("MeshPart", InstanceProperties.MeshPart)),
	UnionOperation = WithAttributes(CreateProtectedInstanceReader("UnionOperation", InstanceProperties.UnionOperation)),
	Texture = CreateInstanceReader("Texture", InstanceProperties.Texture),
	BlockMesh = CreateInstanceReader("BlockMesh", InstanceProperties.BlockMesh),
	PointLight = CreateInstanceReader("PointLight", InstanceProperties.PointLight),
	SpotLight = CreateInstanceReader("SpotLight", InstanceProperties.SpotLight),
	SurfaceLight = CreateInstanceReader("SurfaceLight", InstanceProperties.SurfaceLight),
	SpecialMesh = CreateInstanceReader("SpecialMesh", InstanceProperties.SpecialMesh),
	Decal = CreateInstanceReader("Decal", InstanceProperties.Decal),
	Fire = CreateInstanceReader("Fire", InstanceProperties.Fire),
	Smoke = CreateInstanceReader("Smoke", InstanceProperties.Smoke),
	Attachment = CreateInstanceReader("Attachment", InstanceProperties.Attachment),
}

return ReadInstance]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBX6314C41DDF424602AE6498DF76283837">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">StringConversion</string>
				<string name="ScriptGuid">{4619D5F4-8CC6-4993-810A-00B7AE8F3CAE}</string>
				<ProtectedString name="Source"><![CDATA[local CHARACTER_SET = {
	"b",
	"c",
	"d",
	"f",
	"g",
	"h",
	"j",
	"k",
	"m",
	"p",
	"q",
	"r",
	"t",
	"v",
	"w",
	"x",
	"y",
	"3",
	"4",
	"6",
	"7",
	"8",
	"9",
	"!",
	'"',
	"#",
	"$",
	"%",
	"&",
	"'",
	"(",
	")",
	"*",
	"+",
	",",
	"-",
	".",
	"/",
	":",
	";",
	"<",
	"=",
	">",
	"?",
	"@",
	"B",
	"C",
	"D",
	"F",
	"G",
	"H",
	"J",
	"K",
	"M",
	"P",
	"Q",
	"R",
	"T",
	"V",
	"W",
	"X",
	"Y",
	"[",
	"\\",
	"]",
	"^",
	"_",
	"`",
	"{",
	"|",
	"}",
	"~",
}

local characterKeys = {}
local characterValues = {}
for i, v in pairs(CHARACTER_SET) do
	characterKeys[v] = i - 1
	characterValues[i - 1] = v
end

local CHAR_COUNT = #CHARACTER_SET
return {
	StringToNumber = function(str, cursor, size)
		local total = 0
		for i = cursor, cursor + size - 1 do
			local char = str:sub(cursor, cursor)
			total = total * CHAR_COUNT + characterKeys[char]
			cursor += 1
		end
		return total
	end,

	NumberToString = function(number, charCount)
		local str = ""
		local iteration = 0
		while number >= 0 and iteration < charCount do
			local value = number % CHAR_COUNT
			str = characterValues[value] .. str
			number = math.floor(number / CHAR_COUNT)
			iteration += 1
		end
		return str
	end,

	GetMaxNumber = function(charCount)
		return math.pow(CHAR_COUNT, charCount) - 1
	end,
}]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBX546D7FD21E994F008A109063EBED19BB">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Types</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXC763C2166494405E9D18D5CE77D986E4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">AttributeTypes</string>
					<string name="ScriptGuid">{E0492BC7-1436-476A-B47C-C2A13286F6AC}</string>
					<ProtectedString name="Source"><![CDATA[local AttributeTypes

AttributeTypes = {
	Float = 1,
	Int = 2,
	String = 3,
	Bool = 4,
	Color3 = 5,
	Vector3 = 6,
	LongInt = 7,
	SignedInt = 8,
}

return AttributeTypes]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX3C03321F0D8F4559BBFC69AE1A660922">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DefaultProperties</string>
					<string name="ScriptGuid">{AD4A366D-00BB-4835-9039-951D60D50794}</string>
					<ProtectedString name="Source"><![CDATA[return {
	Part = {
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
	},
}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX1FDD049CA7464670AB0271ACB12835EE">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">InstanceProperties</string>
					<string name="ScriptGuid">{06895180-EF08-4509-80C9-69989FC55395}</string>
					<ProtectedString name="Source"><![CDATA[local InstanceProperties

-- Format:
-- [TypeName], [ValueType], [DefaultValue]
-- eg. "Position", "Vector3", "Vector3.new(0, 0, 0)"

InstanceProperties = { -- any changes to this table should be changed in InstanceTypes.lua
	Model = {
		{ "Name", "String", "Model" },
	},
	Folder = {
		{ "Name", "String", "Folder" },
	},
	Part = {
		{ "Name", "String", "Part" },
		{ "CFrame", "CFrame", CFrame.new() },
		{ "Color", "Color3", Color3.new() },
		{ "Size", "Vector3", Vector3.new() },
		{ "Anchored", "Bool", true },
		{ "CanCollide", "Bool", true },
		{ "Transparency", "ShortBoundedFloat", 0 },
		{ "Material", "Material", "Plastic" },
		{ "CastShadow", "Bool", false },
		{ "Shape", "PartType", "Block" },
	},
	BoolValue = {
		{ "Name", "String", "Value" },
		{ "Value", "Bool", false },
	},
	WedgePart = {
		{ "Name", "String", "Wedge" },
		{ "CFrame", "CFrame", CFrame.new() },
		{ "Color", "Color3", Color3.new() },
		{ "Size", "Vector3", Vector3.new() },
		{ "Anchored", "Bool", true },
		{ "CanCollide", "Bool", true },
		{ "Transparency", "ShortBoundedFloat", 0 },
		{ "Material", "Material", "Plastic" },
		{ "CastShadow", "Bool", false },
	},
	StringValue = {
		{ "Name", "String", "StringValue" },
		{ "Value", "String", "" },
	},
	MeshPart = {
		{ "Name", "String", "Part" },
		{ "CFrame", "CFrame", CFrame.new() },
		{ "Color", "Color3", Color3.new() },
		{ "Size", "Vector3", Vector3.new() },
		{ "Anchored", "Bool", true },
		{ "CanCollide", "Bool", true },
		{ "Transparency", "ShortBoundedFloat", 0 },
		{ "Material", "Material", "Plastic" },
		{ "CastShadow", "Bool", false },
		{ "MeshId", "String", "" },
		{ "TextureID", "String", "" },
	},
	UnionOperation = {
		{ "Name", "String", "Part" },
		{ "CFrame", "CFrame", CFrame.new() },
		{ "Color", "Color3", Color3.new() },
		{ "Size", "Vector3", Vector3.new() },
		{ "Anchored", "Bool", true },
		{ "CanCollide", "Bool", true },
		{ "Transparency", "ShortBoundedFloat", 0 },
		{ "Material", "Material", "Plastic" },
		{ "CastShadow", "Bool", false },
		{ "MeshId", "String", "" },
	},
	Texture = {
		{ "Name", "String", "Texture" },
		{ "Color3", "Color3", Color3.new() },
		{ "OffsetStudsU", "Float", 0 },
		{ "OffsetStudsV", "Float", 0 },
		{ "StudsPerTileU", "Float", 0 },
		{ "StudsPerTileV", "Float", 0 },
		{ "Texture", "String", "" },
		{ "Transparency", "ShortBoundedFloat", 0 },
		{ "ZIndex", "Int", 0 },
		{ "Face", "NormalId", "Front" },
	},
	BlockMesh = {
		{ "Scale", "Vector3", Vector3.new(1, 1, 1) },
		{ "Offset", "Vector3", Vector3.new(0, 0, 0) },
	},
	PointLight = {
		{ "Name", "String", "PointLight" },
		{ "Brightness", "Float", 1 },
		{ "Color", "Color3", Color3.new(1, 1, 1) },
		{ "Enabled", "Bool", true },
		{ "Range", "Float", 20 },
		{ "Shadows", "Bool", false },
	},
	SpotLight = {
		{ "Name", "String", "SpotLight" },
		{ "Angle", "Float", 90 },
		{ "Brightness", "Float", 1 },
		{ "Color", "Color3", Color3.new(1, 1, 1) },
		{ "Enabled", "Bool", true },
		{ "Face", "NormalId", Enum.NormalId.Front },
		{ "Range", "Float", 16 },
		{ "Shadows", "Bool", false },
	},
	SurfaceLight = {
		{ "Name", "String", "SurfaceLight" },
		{ "Angle", "Float", 90 },
		{ "Brightness", "Float", 1 },
		{ "Color", "Color3", Color3.new(1, 1, 1) },
		{ "Enabled", "Bool", true },
		{ "Face", "NormalId", Enum.NormalId.Front },
		{ "Range", "Float", 16 },
		{ "Shadows", "Bool", false },
	},
	SpecialMesh = {
		{ "Name", "String", "Mesh" },
		{ "MeshId", "String", "" },
		{ "MeshType", "MeshType", Enum.MeshType.FileMesh },
		{ "Offset", "Vector3", Vector3.new(0, 0, 0) },
		{ "Scale", "Vector3", Vector3.new(1, 1, 1) },
		{ "VertexColor", "Vector3", Vector3.new(1, 1, 1) },
		{ "TextureId", "String", "" },
	},
	Decal = {
		{ "Name", "String", "Mesh" },
		{ "Color3", "Color3", Color3.new() },
		{ "Texture", "String", "" },
		{ "Transparency", "ShortBoundedFloat", 0 },
		{ "ZIndex", "Int", 0 },
		{ "Face", "NormalId", "Front" },
	},
	Fire = {
		{ "Name", "String", "Mesh" },
		{ "Color", "Color3", Color3.new() },
		{ "Enabled", "Bool", true },
		{ "Heat", "Float", 9 },
		{ "SecondaryColor", "Color3", Color3.new() },
		{ "Size", "Float", 5 },
		{ "TimeScale", "Float", 1 },
	},
	Smoke = {
		{ "Name", "String", "Mesh" },
		{ "Color", "Color3", Color3.new() },
		{ "Enabled", "Bool", true },
		{ "Opacity", "Float", 1 },
		{ "RiseVelocity", "Float", 1 },
		{ "Size", "Float", 1 },
		{ "TimeScale", "Float", 1 },
	},
	Attachment = {
		{ "Name", "String", "Mesh" },
		{ "CFrame", "CFrame", CFrame.new() },
		{ "Visible", "Bool", false },
	},
}

return InstanceProperties]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXA8E90A840692464196770A124B1C1BAE">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">InstanceTypes</string>
					<string name="ScriptGuid">{B8097F5C-559A-4B47-A13E-8C3A38178F80}</string>
					<ProtectedString name="Source"><![CDATA[local InstanceTypes = {
	Nil = 1,
	Model = 2,
	Folder = 3,
	Part = 4,
	PartNoAttributes = 5,
	BoolValue = 6,
	WedgePart = 7,
	StringValue = 8,
	MeshPart = 9,
	UnionOperation = 10,
	Texture = 11,
	BlockMesh = 12,
	PointLight = 13,
	SpotLight = 14,
	SurfaceLight = 15,
	SpecialMesh = 16,
	Decal = 17,
	Fire = 18,
	Smoke = 19,
	Attachment = 20,
}

return InstanceTypes]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX2774E9A3EC564F459CE4F60DE2872BB5">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Materials</string>
					<string name="ScriptGuid">{AF3A0594-60E4-4F95-8128-887B57F876E9}</string>
					<ProtectedString name="Source"><![CDATA[local Materials

Materials = {
	Asphalt = 1,
	Basalt = 2,
	Brick = 3,
	Cobblestone = 4,
	Concrete = 5,
	CorrodedMetal = 6,
	CrackedLava = 7,
	DiamondPlate = 8,
	Fabric = 9,
	Foil = 10,
	Forcefield = 11,
	Glacier = 12,
	Glass = 13,
	Granite = 14,
	Grass = 15,
	Ground = 16,
	Ice = 17,
	LeafyGrass = 18,
	Limestone = 19,
	Marble = 20,
	Metal = 21,
	Mud = 22,
	Neon = 23,
	Pavement = 24,
	Pebble = 25,
	Plastic = 26,
	Rock = 27,
	Salt = 28,
	Sand = 29,
	Sandstone = 30,
	Slate = 31,
	SmoothPlastic = 32,
	Snow = 33,
	Wood = 34,
	WoodPlanks = 35,
	ClayRoofTiles = 36,
	Carpet = 37,
}

return Materials]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXF9D0A456A85E4E5992736A09618E6A25">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">MeshType</string>
					<string name="ScriptGuid">{13E931A6-D511-489B-A2DC-90F07391F0D0}</string>
					<ProtectedString name="Source"><![CDATA[return {
	Brick = 1,
	Cylinder = 2,
	FileMesh = 3,
	Head = 4,
	Sphere = 5,
	Toros = 6,
	Wedge = 7,
}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXB60CEA5ED9DD480AA72019D440E80339">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">NormalId</string>
					<string name="ScriptGuid">{DD145490-B841-441D-AA66-7F665B840B6B}</string>
					<ProtectedString name="Source"><![CDATA[return {
	Top = 1,
	Bottom = 2,
	Left = 3,
	Right = 4,
	Front = 5,
	Back = 6,
}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXDA866A047500460DA9DF06FC1D31504D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PartTypes</string>
					<string name="ScriptGuid">{50F7A7EC-72F2-4027-A2F9-3C1764838BF3}</string>
					<ProtectedString name="Source"><![CDATA[local PartTypes

PartTypes = {
    Ball = 1,
    Cylinder = 2,
    Block = 3,
    Wedge = 4,
    CornerWedge = 5
}

return PartTypes]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX1BB09AE91864423F9C156DB7051CD0B3">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Util</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXAA3F0FB78C514414B7FD601B5C892E5C">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Actor</string>
					<string name="ScriptGuid">{9EE7A6E4-7AAC-44BA-9081-8DC0D5241361}</string>
					<ProtectedString name="Source"><![CDATA[local module = {
	Create = require(script.Parent._ActorCreation._Create),

	State = require(script.Parent._ActorState._State),
	Derived = require(script.Parent._ActorState._Derived),
	DerivedTable = require(script.Parent._ActorState._DerivedTable),
	Watch = require(script.Parent._ActorState._Watch),

	Spring = require(script.Parent._ActorAnim._ActorSpring),
	Cubic = require(script.Parent._ActorAnim._Cubic),

	OnChange = require(script.Parent._OnChange),
}

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX251750E560C94EB18A3F23A3C4FDB9C2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">AxisAlign</string>
					<string name="ScriptGuid">{0545C6B1-371D-4084-B7A6-3F7E17D1E587}</string>
					<ProtectedString name="Source"><![CDATA[local AxisAlign = {}

local VECTOR_UP = Vector3.new(0, 1, 0)

function AxisAlign.BestMatch(cfr, axis)
	local comp = axis or VECTOR_UP
	
	local v0, v1, v2 = cfr:VectorToWorldSpace(VECTOR_UP), cfr:VectorToWorldSpace(Vector3.new(1, 0, 0)), cfr:VectorToWorldSpace(Vector3.new(0, 0, 1))
	local d0, d1, d2 = v0:Dot(comp), v1:Dot(comp), v2:Dot(comp)
	
	if d0 < 0 then
		d0 = -d0
		v0 = -v0
	end
	if d1 < 0 then
		d1 = -d1
		v1 = -v1
	end
	if d2 < 0 then
		d2 = -d2
		v2 = -v2
	end
	
	if d1 > d0 then
		d1, d0 = d0, d1
		v1, v0 = v0, v1
	end
	if d2 > d0 then
		d2, d0 = d0, d2
		v2, v0 = v0, v2
	end
	
	return v0, v1, v2
end

function AxisAlign.CameraAlign(cfr, axis)
	local _, v0, v1 = AxisAlign.BestMatch(cfr, axis)
	
	local cam = workspace.CurrentCamera.CFrame.LookVector
	if math.abs(v1:Dot(cam)) > math.abs(v0:Dot(cam)) then
		v0 = v1
	end
	
	local flat = Vector3.new(v0.X, 0, v0.Z).Unit
	return flat, flat:Cross(VECTOR_UP)
end

return AxisAlign]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX33B5BA14E5B04FBCA5D2FF03FD0753C1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Button</string>
					<string name="ScriptGuid">{F4EF4E22-F63E-4851-8711-42D5045E10A8}</string>
					<ProtectedString name="Source"><![CDATA[local Actor = require(script.Parent.Actor)
local Create = Actor.Create
local State = Actor.State
local Derived = Actor.Derived

return function(props)
	local enabled = props.Enabled or State(false)
	
	return Create("TextButton", {
		BorderSizePixel = 0,
		Size = props.Size or UDim2.new(0, 200, 0, 40),
		Text = props.Text,
		BackgroundTransparency = Derived(function(e)
			return e and 0 or 0.5
		end, enabled),
		BackgroundColor3 = Derived(function(e)
			return e and Color3.new(1, 1, 1) or Color3.new(0, 0, 0)
		end, enabled),
		TextColor3 = Derived(function(e)
			return e and Color3.new(0, 0, 0) or Color3.new(1, 1, 1)
		end, enabled),
		
		TextSize = 20,
		Font = Enum.Font.SciFi,
		
		Activated = props.Activated,
		Position = props.Position,
		AnchorPoint = props.AnchorPoint
	})
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX162385CDE3C743F1A463ED8F5DC4A3D7">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">StringConversion</string>
					<string name="ScriptGuid">{7C16C33E-35CA-449E-A2B6-DC77B9DC1CCA}</string>
					<ProtectedString name="Source"><![CDATA[local CHARACTER_SET = {	'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'm', 'p', 'q', 'r', 't', 'v', 'w', 'x', 'y',
						'3', '4', '6', '7', '8', '9', '!', '\"', '#', '$', '%', '&', '\'',	'(', ')', '*', '+', ',', '-', '.', '/',
						':', ';', '<', '=', '>', '?', '@', 'B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'M', 'P', 'Q', 'R', 'T', 'V', 'W', 'X', 'Y',
						'[', '\\', ']', '^', '_', '`', '{', '|', '}', '~'}

local characterKeys = {}
local characterValues = {}
for i, v in pairs(CHARACTER_SET) do
    characterKeys[v] = i - 1;
    characterValues[i - 1] = v;
end

local CHAR_COUNT = #CHARACTER_SET
return {
	StringToNumber = function(str, cursor, size)
		local total = 0
		for i = cursor, cursor + size - 1 do
			local char = str:sub(cursor, cursor)
			total = total * CHAR_COUNT + characterKeys[char]
			cursor += 1
		end 
		return total
	end,
	
	NumberToString = function(number, charCount)
		local str = ""
		local iteration = 0
		while number >= 0 and iteration < charCount do
			local value = number % CHAR_COUNT
			str = characterValues[value] .. str
			number = math.floor(number / CHAR_COUNT)
			iteration += 1
		end
		return str
	end,

	GetMaxNumber = function(charCount)
		return math.pow(CHAR_COUNT, charCount) - 1
	end,
}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX3A82C46DEDC74922B61E30EC23C7049D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ZoneUtil</string>
					<string name="ScriptGuid">{EEF22715-E15E-4321-99F3-4F4B9078C2A6}</string>
					<ProtectedString name="Source"><![CDATA[local ZoneUtil = {}

function ZoneUtil.InZone(zone, pos)
	local floorMatch = zone:FindFirstChild("Floor") == nil
	local roofMatch = false

	for _, part in pairs(zone:GetChildren()) do
		local rel = part.CFrame:PointToObjectSpace(pos)

		if math.abs(rel.X) <= part.Size.X / 2 and math.abs(rel.Z) <= part.Size.Z / 2 then
			if part.Name == "Roof" and rel.Y <= 0 then
				roofMatch = true
			elseif part.Name == "Floor" and rel.Y >= 0 then
				floorMatch = true
			end

			if floorMatch and roofMatch then
				return true
			end
		end
	end
	
	return false
end

function ZoneUtil.GetZone(pos)
	local LevelBase = workspace:FindFirstChild("DebugMission") or workspace:FindFirstChild("Level")
	for _, zone in pairs(LevelBase.Cells:GetChildren()) do
		if ZoneUtil.InZone(zone, pos) then
			return zone
		end
	end
end

return ZoneUtil]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX0EA3AB5BFB1D48129891F079BADD98A0">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">_ActorAnim</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX3762A6B5E5774059BB177633A09E5794">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">_ActorSpring</string>
						<string name="ScriptGuid">{E9B5446E-4C51-4D3F-A697-2FC646AD08C0}</string>
						<ProtectedString name="Source"><![CDATA[local AnimRunner = require(script.Parent._Anim)

local numberClose = function(x, y)
	return math.abs(x - y) < 0.01
end
local vectorClose = function(x, y)
	return (x - y).magnitude < 0.01
end
local udim2Close = function(x, y)
	local rel = x - y
	return math.abs(rel.X.Offset) <= 1 and math.abs(rel.Y.Offset) <= 1 and math.abs(rel.X.Scale) < 0.01 and math.abs(rel.Y.Scale) < 0.01 
end

local function getStartingVelocityByType(value)
	if typeof(value) == "number" then
		return 0, numberClose
	elseif typeof(value) == "Vector3" then
		return Vector3.new(), vectorClose
	--elseif typeof(value) == "UDim2" then
	--	return UDim2.new(), udim2Close
	end
end

local Spring = {
	_Update = function(self)
		self.T = self._Follow._Value
		if self._Active then return true end
		AnimRunner:Start(self)
	end,
	_Step = function(self, dt)
		if self._IsClose(self._Value, self.T) then
			self._Value = self.T
			return true
		end
		if dt > 0.03 then dt = 0.03 end
		local accel = (self.T - self._Value) * self._Force - self.V * self._Damping
		local vel = self.V
		self.V = self.V + accel * dt * self._Speed
		self._Value = self._Value + (self.V + vel) * dt * 0.5 * self._Speed
		return false
	end,
	_GetDependencies = function(self)
		return { self._Follow }
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		self._Follow._Dependent[self] = true
		if self._Follow._Init then
			self._Follow:_Init()
		end
		self._Value = self._Follow._Value -- Position
		self.T = self._Follow._Value -- Target
		self.V, self._IsClose = getStartingVelocityByType(self._Follow._Value)
	end
}
Spring.__index = Spring

return function(follow, force, damping, speed)
	local self = {}
	self._StateType = "_Spring"
	self._Active = false
	self._Follow = follow
	self._Force = force or 50
	self._Damping = damping or 10
	self._Speed = speed or 1
	self._Temp = follow._Temp

	self._Priority = follow._Priority + 1
	self._Dependent = {}
	self._Link = {}

	setmetatable(self, Spring)
	return self
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5F81A58F0B2345C591D24E291256D3A1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">_Anim</string>
						<string name="ScriptGuid">{C0139DD1-ABA2-4488-9B03-86C57511A6A8}</string>
						<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local Update = require(script.Parent.Parent._ActorState._Update)

local Anim = {}
Anim._List = {}
Anim._Active = false

function Anim:Start(data)
	self._List[data] = true
	data._Active = true
	if self._Active then return end
	self._Active = true
	self._StepEvent = RunService.RenderStepped:Connect(function(dt)
		for data in pairs(self._List) do
			if data:_Step(dt) then
				self._List[data] = nil
				data._Active = false
			end
			Update(data)
		end
		if not next(self._List) then
			self._Active = false
			self._StepEvent:Disconnect()
			self._StepEvent = nil
		end
	end)
end

return Anim]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9EE08A090C2B425FA9D80EA831DE83BB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">_Cubic</string>
						<string name="ScriptGuid">{EDB8C0AB-6D14-43AC-A672-DFF4FBA549CD}</string>
						<ProtectedString name="Source"><![CDATA[local DEFAULT_LINEAR_TRANSITION_RATE = 4

local AnimRunner = require(script.Parent.Parent._ActorAnim._Anim)

local Cubic = {
	_Update = function(self)
		self.T = self._Follow._Value
		if self._Active then return true end
		AnimRunner:Start(self)
	end,
	_Step = function(self, dt)
		local shift = dt * self._Speed
		local done = false
		if math.abs(self.T - self.P) < shift then
			self.P = self.T
			done = true
		elseif self.P < self.T then
			self.P += shift
		else
			self.P -= shift
		end
		local a = self.P
		self._Value = a * a * (-2 * a + 3)
		return done
	end,
	_GetDependencies = function(self)
		return { self._Follow }
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		self._Follow._Dependent[self] = true
		if self._Follow._Init then
			self._Follow:_Init()
		end
		local a = self._Follow._Value
		self.P = a -- Position
		self.T = a -- Target
		self._Value = a * a * (-2 * a + 3)
	end
}
Cubic.__index = Cubic

return function(follow, speed)
	local self = {}
	self._StateType = "_Cubic"
	self._Active = false
	self._Follow = follow
	self._Speed =  DEFAULT_LINEAR_TRANSITION_RATE
	if speed then
		self._Speed = self._Speed * speed
	end
	self._Temp = follow._Temp

	self._Priority = follow._Priority + 1
	self._Dependent = {}
	self._Link = {}

	setmetatable(self, Cubic)
	return self
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8B779A50CA9C49F1892B4B6F0415B4E1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">_Linear</string>
						<string name="ScriptGuid">{5575D17B-E29E-4411-BC94-C72ADFF2A854}</string>
						<ProtectedString name="Source"><![CDATA[local DEFAULT_LINEAR_TRANSITION_RATE = 4

local AnimRunner = require(script.Parent.Parent._ActorAnim._Anim)

local Cubic = {
	_Update = function(self)
		self.T = self._Follow._Value
		if self._Active then return true end
		AnimRunner:Start(self)
	end,
	_Step = function(self, dt)
		local shift = dt * self._Speed
		local done = false
		if math.abs(self.T - self.P) < shift then
			self.P = self.T
			done = true
		elseif self.P < self.T then
			self.P += shift
		else
			self.P -= shift
		end
		local a = self.P
		self._Value = a * a * (-2 * a + 3)
		return done
	end,
	_GetDependencies = function(self)
		return { self._Follow }
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		self._Follow._Dependent[self] = true
		if self._Follow._Init then
			self._Follow:_Init()
		end
		local a = self._Follow._Value
		self.P = a -- Position
		self.T = a -- Target
		self._Value = a * a * (-2 * a + 3)
	end
}
Cubic.__index = Cubic

return function(follow, speed)
	local self = {}
	self._StateType = "_Cubic"
	self._Active = false
	self._Follow = follow
	self._Speed =  DEFAULT_LINEAR_TRANSITION_RATE
	if speed then
		self._Speed = self._Speed * speed
	end
	self._Temp = follow._Temp

	self._Priority = follow._Priority + 1
	self._Dependent = {}
	self._Link = {}

	setmetatable(self, Cubic)
	return self
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX6ABF696F82684DD6ACB258907F012350">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">_ActorCreation</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX3E29C28D38DA4B3BA5A1EB8CC56D2C1D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">_Create</string>
						<string name="ScriptGuid">{1FDBB29C-7F89-43E0-92E3-ADC9728654C5}</string>
						<ProtectedString name="Source"><![CDATA[local TABLE = "table"
local SCRIPT_SIGNAL = "RBXScriptSignal"
local INST = "Instance"
local DEBUG = "Debug"
local TEMP_STATE = "TempState"

local HandleStateCleanup = require(script.Parent:WaitForChild("_HandleStateCleanup"))


local function processChildren(parent, item, stateLink)
	if typeof(item) == INST then
		item.Parent = parent
		return
	end
	if item._DerivedTable then
		item:_Init()
		item.OnAdd = function(_, instance)
			if typeof(instance) == INST then
				instance.Parent = parent
			end
		end
		item.OnRemove = function(_, instance)
			if typeof(instance) == INST then
				instance:Destroy()
			end
		end
		for _, instance in pairs(item._Value) do
			if typeof(instance) == INST then
				instance.Parent = parent
			end
		end
		if stateLink then
			table.insert(stateLink, item)
		end
	else
		for _, c in pairs(item) do
			processChildren(parent, c, stateLink)
		end
	end
end

return function(className, props, children, autoCleanup)
	local instance = Instance.new(className)

	local stateLink
	if autoCleanup then
		stateLink = {}
	end

	for name, value in pairs(props) do
		if name == DEBUG or name == TEMP_STATE then continue end

		if typeof(value) == TABLE then
			if value._StateType then
				value._Link[instance] = name
				if value._Init then
					value:_Init()
				end
				instance[name] = value._Value
				if autoCleanup then
					table.insert(stateLink, value)
				end
			end
		elseif typeof(name) == TABLE then
			if name._OnChange then
				local propName = name._Property
				instance:GetPropertyChangedSignal(propName):Connect(function() value(instance[propName]) end)
				value(props[propName] or instance[propName])
			end
		elseif typeof(instance[name]) == SCRIPT_SIGNAL then
			instance[name]:Connect(value)
		else
			instance[name] = value
		end
	end

	if children then
		processChildren(instance, children, autoCleanup and stateLink)
	end

	if autoCleanup and next(stateLink) then
		instance.AncestryChanged:Connect(function()
			if instance.Parent == nil then
				if props.Debug then
					warn("Cleanup:", props.Debug, stateLink)
				end
				for _, dep in pairs(stateLink) do
					dep._Link[instance] = nil
					HandleStateCleanup(dep)
				end
			end
		end)
	end

	return instance
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF2AA97D459D94E60934C2CA5096D933A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">_HandleStateCleanup</string>
						<string name="ScriptGuid">{D6ACDE87-9C47-4BC6-B27E-93CDE839B49A}</string>
						<ProtectedString name="Source"><![CDATA[local cleanup
cleanup = function(state)
	if state.Debug then
		warn(state.Debug, state._Temp, state._GetDependencies ~= nil, next(state._Dependent), next(state._Link))
	end
	if not state._Persist and state._GetDependencies and not next(state._Dependent) and not next(state._Link) then
		if state.Debug then
			warn("Cleanup", state.Debug, state:_GetDependencies())
		end
		state._Initialized = false
		for _, dep in pairs(state:_GetDependencies()) do
			dep._Dependent[state] = nil
			cleanup(dep)
		end
	end
end

return cleanup]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXFE02C6E3B0D9411CB12C531EB636BF32">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">_ActorState</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX064A73268BD8436C870588A731798B2F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">_Derived</string>
						<string name="ScriptGuid">{6414DA3D-A280-4312-84DA-BD293DF452B4}</string>
						<ProtectedString name="Source"><![CDATA[local Derived = {
	_Update = function(self)
		local values = {}
		for k, v in pairs(self._Dependencies) do
			values[k] = v._Value or false
		end
		local newValue = self._Eval(unpack(values))
		if newValue ~= self._Value then
			self._Value = newValue
			return true
		end
		return false
	end,
	_GetDependencies = function(self)
		return self._Dependencies
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		for _, v in pairs(self._Dependencies) do
			v._Dependent[self] = true
			if v._Init then
				v:_Init()
			end
		end
		self:_Update()
	end
}
Derived.__index = Derived

return function(eval, ...)
	local self = {}
	self._StateType = "_Derived"
	self._Eval = eval
	self._Dependencies = {...}

	local priority = 0
	local temp = false
	for k, v in pairs(self._Dependencies) do
		priority = math.max(priority, v._Priority)
		temp = temp or v._Temp
	end

	self._Priority = priority + 1
	self._Temp = temp

	self._Dependent = {}
	self._Link = {}

	setmetatable(self, Derived)
	return self
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6943C05007FD450380E056A50A13AA5A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">_DerivedTable</string>
						<string name="ScriptGuid">{003DF383-D036-4B52-A4F0-7447C1BFC1E9}</string>
						<ProtectedString name="Source"><![CDATA[local DerivedTable = {
	_Update = function(self)
		local changed = false
		local input = self._Input._Value

		for k, v in pairs(input) do
			local li = self._LastInput[k]
			if v ~= li then
				changed = true
				if li and self.OnRemove then
					self.OnRemove(k, self._Value[k])
				end
				self._LastInput[k] = v
				self._Value[k] = self._Eval(k, v)
				if self.OnAdd then
					self.OnAdd(k, self._Value[k])
				end
			end
		end

		for k, v in pairs(self._LastInput) do
			if not input[k] then
				if self.OnRemove then
					self.OnRemove(k, self._Value[k])
				end
				self._LastInput[k] = nil
				changed = true
			end
		end

		return changed
	end,
	_GetDependencies = function(self)
		return { self._Input }
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		self._Input._Dependent[self] = true
		if self._Input._Init then
			self._Input:_Init()
		end
		self:_Update()
	end
}
DerivedTable.__index = DerivedTable

return function(eval, input, onAdd, onRemove)
	local self = {}
	self._StateType = "_DerivedTable"
	self._DerivedTable = true
	self._Eval = eval
	self._Value = {}
	self._LastInput = {}
	self._Input = input
	self._Temp = input._Temp
	self._Priority = input._Priority + 1

	self.OnAdd = onAdd
	self.OnRemove = onRemove

	self._Dependent = {}
	self._Link = {}

	setmetatable(self, DerivedTable)
	return self
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6C1D620BE8FF400FBBF9D9235116438A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">_State</string>
						<string name="ScriptGuid">{B6E9AB97-7A1D-485A-8CCF-000569B41754}</string>
						<ProtectedString name="Source"><![CDATA[local Update = require(script.Parent:WaitForChild("_Update"))

local State = {
	set = function(self, value)
		if self._Value == value then
			return
		end
		self._Value = value
		Update(self)
	end,
}
State.__index = State

return function(value)
	local self = {}
	self._StateType = "_State"
	self._State = true
	self._Value = value
	self._Priority = 0
	self._Dependent = {}
	self._Link = {}
	self._Temp = false

	setmetatable(self, State)
	return self
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1CF098446D014BA882FDCB4B86C9B93F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">_Update</string>
						<string name="ScriptGuid">{3F389F76-70F1-4453-9EEA-835BC0773102}</string>
						<ProtectedString name="Source"><![CDATA[return function(base)
	local list = {}

	for instance, prop in pairs(base._Link) do
		instance[prop] = base._Value
	end

	for dep in pairs(base._Dependent) do
		list[dep] = true
	end

	local best = next(list)
	while best do
		local priority = best._Priority
		for dep in pairs(list) do
			if dep._Priority < priority then
				best = dep
				priority = best._Priority
			end
		end
		list[best] = nil

		if best:_Update() then -- this updated and we need to change it's dependencies
			for instance, prop in pairs(best._Link) do
				instance[prop] = best._Value
			end
			for dep in pairs(best._Dependent) do
				list[dep] = true
			end
		end

		best = next(list)
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0B44BB9D01F14CE6A88DB482CFF79B89">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">_Watch</string>
						<string name="ScriptGuid">{13BB76D5-A77A-4B22-8212-EE8B0F259A44}</string>
						<ProtectedString name="Source"><![CDATA[local Watch = {
	_Update = function(self)
		local values = {}
		for k, v in pairs(self._Dependencies) do
			values[k] = v._Value or false
		end
		-- Make Watch Callback
        self._Eval(unpack(values))
		return false
	end,
	_GetDependencies = function(self)
		return self._Dependencies
	end,
	_Init = function(self)
		if self._Initialized then return end
		self._Initialized = true
		for _, v in pairs(self._Dependencies) do
			v._Dependent[self] = true
			if v._Init then
				v:_Init()
			end
		end
		self:_Update()
	end
}
Watch.__index = Watch

return function(eval, ...)
	local self = {}
	self._StateType = "_Watch"
	self._Eval = eval
	self._Dependencies = {...}

	local priority = 0
	local temp = false
	for k, v in pairs(self._Dependencies) do
		priority = math.max(priority, v._Priority)
		temp = temp or v._Temp
	end

	self._Priority = priority + 1
	self._Temp = temp

	self._Dependent = {}
	self._Link = {}

	setmetatable(self, Watch)

    -- Unlike other state components, we want to init this one immediataly as it will never connect to an instance
    -- Any dependencies will never be released, only use this for debugging or if you're sure those state components don't need to be gced
    self:_Init()

	return self
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXCBA3CE48E93E46C998ECBDB619124FEA">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">_OnChange</string>
					<string name="ScriptGuid">{00636C99-47D6-49D4-8543-3EA310A940F3}</string>
					<ProtectedString name="Source"><![CDATA[return function(prop)
	return {
		_OnChange = true,
		_Property = prop,
	}
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX5FB3F528C5924FF1B619C282CA67C523">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Writing</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXE2E2D89BF1C745E482838549EA5C3254">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Main</string>
					<string name="ScriptGuid">{F85EB270-CB2F-4A31-A454-1918D8B5A597}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ScriptEditorService = game:GetService("ScriptEditorService")
local UserInputService = game:GetService("UserInputService")
local Write = require(script.Parent.Write)
local StringConversion = require(script.Parent.Parent.StringConversion)
local Read = require(script.Parent.Parent.Reading.Read)

local Button = require(script.Parent.Parent.Util.Button)

local Actor = require(script.Parent.Parent.Util.Actor)
local Create = Actor.Create
local State = Actor.State
local Derived = Actor.Derived
local DerivedTable = Actor.DerivedTable

local MAX_PASTE_SIZE = 199999
local PASTE_INFO_SIZE = 7
local PASTE_SIZE = MAX_PASTE_SIZE - PASTE_INFO_SIZE

local VERSION_NUMBER = 0

local module = {}

module.Init = function(mouse: PluginMouse)
	if module.Active then
		return
	end
	module.Active = true

	local CodeState = State("")
	local Pastes = State({})

	Pastes = Derived(function(code)
		local codeChunks = {}
		local first = 1
		local current = PASTE_SIZE -- leaving space for paste information
		local currentPaste = 1
		local maxPastes = math.ceil(#code / current)
		local mapId = math.random(1, StringConversion.GetMaxNumber(2)) -- A 3 character integer that can be used to identify maps
		while first < #code do
			local prePaste = ""
			prePaste = StringConversion.NumberToString(VERSION_NUMBER, 1)
			prePaste = prePaste .. Write.ShortInt(mapId)
			prePaste = prePaste .. Write.ShortInt(currentPaste)
			prePaste = prePaste .. Write.ShortInt(maxPastes)
			codeChunks[#codeChunks + 1] = prePaste .. code:sub(first, current) .. "\r"
			first += PASTE_SIZE
			current += PASTE_SIZE
			currentPaste += 1
		end
		return codeChunks
	end, CodeState)

	module.UI = Create("ScreenGui", {
		Parent = game.StarterGui,
		Archivable = false,
	}, {
		Button({
			Size = UDim2.new(0, 200, 0, 30),
			Enabled = module.EnabledState,
			Position = UDim2.new(0, 50, 0, 50),
			Text = "Generate Code",
			Activated = function()
				local mission = workspace:FindFirstChild("DebugMission")
					or game.ReplicatedStorage:FindFirstChild("DebugMission")
				if not mission then
					error(
						"No mission found: Mission must be named 'DebugMission' and placed in workspace or ReplicatedStorage"
					)
				end
				local code = Write.Mission(mission)

				if not workspace:FindFirstChild("DebugMission") then
					local model = Read.Mission(code, 1)
					model.Parent = workspace
				end
				CodeState:set(code)
			end,
		}),
		if workspace:GetAttribute("ReadDocs")
			then Button({
				Size = UDim2.new(0, 200, 0, 30),
				Enabled = module.EnabledState,
				Position = UDim2.new(0, 270, 0, 50),
				Text = "Gist Code",
				Activated = function()
					local mission = workspace:FindFirstChild("DebugMission")
						or game.ReplicatedStorage:FindFirstChild("DebugMission")
					if not mission then
						error(
							"No mission found: Mission must be named 'DebugMission' and placed in workspace or ReplicatedStorage"
						)
					end
					local code = Write.Mission(mission)

					if not workspace:FindFirstChild("DebugMission") then
						local model = Read.Mission(code, 1)
						model.Parent = workspace
					end

					local output = ""
					output = StringConversion.NumberToString(VERSION_NUMBER, 1)
					output = output .. Write.ShortInt(math.random(1, 100))
					output = output .. Write.ShortInt(1)
					output = output .. Write.ShortInt(1)
					output = output .. code

					if workspace:FindFirstChild("CustomMissionCode") then
						workspace.CustomMissionCode:Destroy()
					end

					local s = Instance.new("Script")
					s.Name = "CustomMissionCode"
					ScriptEditorService:UpdateSourceAsync(s, function()
						return output
					end)
					s.Parent = workspace
					ScriptEditorService:OpenScriptDocumentAsync(s)
				end,
			})
			else nil,
		Create("ScrollingFrame", {
			Size = UDim2.new(0, 200, 1, -150),
			Position = UDim2.new(0, 50, 1, -50),
			AnchorPoint = Vector2.new(0, 1),
			BackgroundColor3 = Color3.new(0, 0, 0),
			BackgroundTransparency = 0.5,
			Visible = Derived(function(code)
				if code == "" then
					return false
				else
					return true
				end
			end, CodeState),
			CanvasSize = Derived(function(code)
				return UDim2.new(0, 180, 0, 34 * (math.ceil(#code / PASTE_SIZE)))
			end, CodeState),
		}, {
			DerivedTable(function(index, value)
				local textBox = Create("TextBox", {
					ClearTextOnFocus = false,
					Size = UDim2.new(0, 80, 0, 20),
					Position = UDim2.new(0, 10, 0, 5),
					TextEditable = false,
					TextScaled = false,
					TextSize = 10,
					ClipsDescendants = true,
					TextWrapped = false,
					BackgroundTransparency = 1,
					TextColor3 = Color3.new(255, 255, 255),
					BorderSizePixel = 5,
					Text = value,
				})

				local selector = Create("Frame", {
					BackgroundTransparency = 1,
					Size = UDim2.new(0, 200, 0, 50),
					Position = UDim2.new(0, 0, 0, (index - 1) * 34 + 4),
				}, {
					textBox,
					Create("TextButton", {
						Size = UDim2.new(0, 90, 0, 20),
						Position = UDim2.new(0, 100, 0, 5),
						Text = "Select " .. tostring(index),
						FontFace = Font.fromEnum(Enum.Font.SciFi),
						BackgroundColor3 = Color3.new(255, 255, 255),
						BorderColor3 = Color3.new(0, 0, 0),
						TextScaled = false,
						TextSize = 14,
						TextStrokeColor3 = Color3.new(0, 0, 0),
						BorderSizePixel = 0,
						Activated = function()
							textBox:CaptureFocus()
							textBox.SelectionStart = 0
							textBox.CursorPosition = #value + 1
						end,
					}),
				})
				return selector
			end, Pastes),
		}),
	})
end

module.Clean = function()
	if not module.Active then
		return
	end
	module.Active = false

	module.UI:Destroy()
	module.UI = nil
end

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX978B274714C34F27AC51C5E4AD1486C1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Write</string>
					<string name="ScriptGuid">{58FA357F-E7EF-48B5-A991-507711406E94}</string>
					<ProtectedString name="Source"><![CDATA[local StringConversion = require(script.Parent.Parent.StringConversion)
local InstanceTypes = require(script.Parent.Parent.Types.InstanceTypes)
local WriteInstance = require(script.Parent.WriteInstance)
local Materials = require(script.Parent.Parent.Types.Materials)
local PartTypes = require(script.Parent.Parent.Types.PartTypes)
local NormalId = require(script.Parent.Parent.Types.NormalId)
local MeshType = require(script.Parent.Parent.Types.MeshType)

local Write

local SHORTEST_INT_BOUND = StringConversion.GetMaxNumber(1)
local SHORT_INT_BOUND = StringConversion.GetMaxNumber(2)
local INT_BOUND = StringConversion.GetMaxNumber(4)
local LONG_INT_BOUND = StringConversion.GetMaxNumber(6)
local SIGNED_INT_BOUND = math.floor(StringConversion.GetMaxNumber(3) / 2)
local BOUNDED_FLOAT_BOUND = StringConversion.GetMaxNumber(3)
local SHORT_BOUNDED_FLOAT_BOUND = math.floor(StringConversion.GetMaxNumber(2))

local normalize = function(value) -- normalizes an angle in radians (from -pi to pi) to 0-1
	return (value + math.pi) / (math.pi * 2)
end

local function CreateEnumWriter(keys)
	return function(value)
		local index = keys[value.Name] or 1
		return StringConversion.NumberToString(index, 1)
	end
end

Write = {
	Bool = function(bool) -- 1 character
		return if bool then "b" else "c"
	end,

	ShortInt = function(num) -- 2 characters
		if num > SHORT_INT_BOUND then
			return StringConversion.NumberToString(SHORT_INT_BOUND, 2)
		elseif num < 0 then
			return StringConversion.NumberToString(0, 2)
		else
			return StringConversion.NumberToString(num, 2)
		end
	end,

	Int = function(num) -- 4 characters
		if num > INT_BOUND then
			warn("Int out of bounds range:", num)
			return StringConversion.NumberToString(INT_BOUND, 4)
		elseif num < 0 then
			warn("Int out of bounds range:", num)
			return StringConversion.NumberToString(0, 4)
		else
			return StringConversion.NumberToString(num, 4)
		end
	end,

	LongInt = function(num)
		if num > LONG_INT_BOUND then
			warn("Int out of bounds range:", num)
			return StringConversion.NumberToString(LONG_INT_BOUND, 6)
		elseif num < 0 then
			warn("Int out of bounds range:", num)
			return StringConversion.NumberToString(0, 6)
		else
			return StringConversion.NumberToString(num, 6)
		end
	end,

	SignedInt = function(num) -- 3 characters
		if num > SIGNED_INT_BOUND then
			return StringConversion.NumberToString(SIGNED_INT_BOUND * 2, 3)
		elseif num < SIGNED_INT_BOUND * -1 then
			return StringConversion.NumberToString(0, 3)
		else
			return StringConversion.NumberToString(num + SIGNED_INT_BOUND, 3)
		end
	end,

	Float = function(num) -- 5 characters, 3 before decimal, 2 after
		local beforeDecimalStr = Write.SignedInt(math.floor(num))
		local afterDecimalStr =
			StringConversion.NumberToString(math.round((num - math.floor(num)) * SHORT_INT_BOUND), 2)
		return beforeDecimalStr .. afterDecimalStr
	end,

	Vector3 = function(vector) -- 24 characters, 8 for each float of X, Y, & Z
		return Write.Float(vector.X) .. Write.Float(vector.Y) .. Write.Float(vector.Z)
	end,

	CFrame = function(frame) -- 27 characters, 15 for position, 12 for rotation
		local rx, ry, rz = frame:ToEulerAnglesXYZ()
		return Write.Float(frame.X)
			.. Write.Float(frame.Y)
			.. Write.Float(frame.Z)
			.. Write.BoundedFloat(normalize(rx))
			.. Write.BoundedFloat(normalize(ry))
			.. Write.BoundedFloat(normalize(rz))
	end,

	BoundedFloat = function(num) -- 3 characters
		if num > 1 then
			num = 1
		end
		if num < 0 then
			num = 0
		end
		return StringConversion.NumberToString(math.round(num * BOUNDED_FLOAT_BOUND), 3)
	end,

	ShortBoundedFloat = function(num) -- 2 characters
		if num > 1 then
			num = 1
		end
		if num < 0 then
			num = 0
		end
		return StringConversion.NumberToString(math.round(num * SHORT_BOUNDED_FLOAT_BOUND), 2)
	end,

	Color3 = function(color) -- 6 characters
		return Write.ShortBoundedFloat(color.R) .. Write.ShortBoundedFloat(color.G) .. Write.ShortBoundedFloat(color.B)
	end,

	String = function(str) -- 4 + length characters
		return Write.Int(#str) .. str
	end,

	ColorMap = function(colorMap)
		local colorStr = ""
		for i, v in pairs(colorMap) do
			colorStr = colorStr .. Write.Color3(v)
		end
		return Write.ShortInt(#colorMap) .. colorStr
	end,

	StringMap = function(stringMap)
		local stringStr = ""
		for i, v in pairs(stringMap) do
			stringStr = stringStr .. Write.String(v)
		end
		return Write.ShortInt(#stringMap) .. stringStr
	end,

	Mission = function(mission)
		local str = ""
		local colorMap = {}
		local stringMap = {}

		local MissionSetup = require(mission:FindFirstChild("MissionSetup"):Clone())

		while mission:FindFirstChild("StringMissionSetup") do
			mission:FindFirstChild("StringMissionSetup"):Destroy()
		end
		while mission:FindFirstChild("TableMissionSetup") do
			mission:FindFirstChild("TableMissionSetup"):Destroy()
		end

		-- setting Color3s into tables for encoding
		for i, v in pairs(MissionSetup["Colors"]) do
			MissionSetup["Colors"][i] = { v.R, v.G, v.B }
		end

		local json = game:GetService("HttpService"):JSONEncode(MissionSetup)

		local TableMissionSetup = Instance.new("StringValue")
		TableMissionSetup.Name = "TableMissionSetup"
		TableMissionSetup.Value = json
		TableMissionSetup.Parent = mission

		local StringMissionSetup = Instance.new("StringValue")
		StringMissionSetup.Name = "StringMissionSetup"
		StringMissionSetup.Value = mission:FindFirstChild("MissionSetup").Source
		StringMissionSetup.Parent = mission

		str, colorMap, stringMap = Write.Instance(mission, colorMap, stringMap)
		local colorMapStr = Write.ColorMap(colorMap)
		local stringMapStr = Write.StringMap(stringMap)
		return colorMapStr .. stringMapStr .. str
	end,

	Instance = function(object, colorMap, stringMap)
		local className = object.ClassName
		if InstanceTypes[object.ClassName] ~= nil then
			if next(object:GetAttributes()) == nil and object.ClassName == "Part" then
				className = className .. "NoAttributes"
			end
			local instanceType = StringConversion.NumberToString(InstanceTypes[className], 1)
			local objectProperties, colorMap, stringMap = WriteInstance[className](object, Write, colorMap, stringMap)
			local childrenProperties = ""
			for i, v in pairs(object:GetChildren()) do
				childrenProperties = childrenProperties .. Write.Instance(v, colorMap, stringMap)
			end
			return instanceType .. objectProperties .. childrenProperties .. StringConversion.NumberToString(0, 1),
				colorMap,
				stringMap
		else
			return StringConversion.NumberToString(InstanceTypes.Nil, 1), colorMap, stringMap
		end
	end,

	Material = CreateEnumWriter(Materials),
	PartType = CreateEnumWriter(PartTypes),
	NormalId = CreateEnumWriter(NormalId),
	MeshType = CreateEnumWriter(MeshType),
	--[[
	Material = function(material)
		return StringConversion.NumberToString(Materials[material.Name], 1)
	end,

	PartType = function(pType)
		return StringConversion.NumberToString(PartTypes[pType.Name], 1)
	end,

	NormalId = function(pType)
		return StringConversion.NumberToString(NormalId[pType.Name], 1)
	end,
	]]
}

return Write]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX997DE664AC9B4FD6AED870D60A2A7143">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">WriteInstance</string>
					<string name="ScriptGuid">{1BDA8798-05F6-44EA-965F-CE855BA6B116}</string>
					<ProtectedString name="Source"><![CDATA[local StringConversion = require(script.Parent.Parent.StringConversion)
local InstanceProperties = require(script.Parent.Parent.Types.InstanceProperties)
local AttributeTypes = require(script.Parent.Parent.Types.AttributeTypes)
local AttributeValidation = require(script.Parent.Parent.AttributeValidation)

local WithAttributes = function(DefaultWriter)
	return function(object, Write, colorMap, stringMap)
		local str = DefaultWriter(object, Write, colorMap, stringMap)
		local attributes = object:GetAttributes()
		attributes = AttributeValidation.Validate(object.ClassName, object.Name, attributes, false)
		local attString = ""

		-- Encoding Attributes
		for i, v in pairs(attributes) do
			if i:match("^RBX_") then
				continue
			end

			local attributeType = typeof(v) -- Changing attribute type names to match as they are in the Write file
			if typeof(v) == "number" then
				if v ~= math.round(v) or v < 0 then
					attributeType = "Float"
				else
					attributeType = "LongInt"
				end
			elseif typeof(v) == "boolean" then
				attributeType = "bool"
			end
			attributeType = (string.upper(string.sub(attributeType, 1, 1)) .. string.sub(attributeType, 2, -1))
			if AttributeTypes[attributeType] == nil then -- if the attribute is not in the table, ignore it
				continue
			end

			local index = nil
			for ind, val in pairs(stringMap) do -- Check if the attribute is in the stringMap. use the index if it is
				if val == i then
					index = ind
					continue
				end
			end
			if index == nil then -- Otherwise, create a new value in the stringMap and use it
				stringMap[#stringMap + 1] = i
				index = #stringMap
			end
			attString = attString
				.. StringConversion.NumberToString(AttributeTypes[attributeType], 1)
				.. Write.ShortInt(index)

			if attributeType == "Color3" then
				local index = nil
				for ind, val in pairs(colorMap) do
					if v == val then
						index = ind
						continue
					end
				end
				if index == nil then
					colorMap[#colorMap + 1] = v
					index = #colorMap
				end
				attString = attString .. Write.ShortInt(index)
			elseif attributeType == "String" then
				local index = nil
				for ind, val in pairs(stringMap) do
					if val == v then
						index = ind
						continue
					end
				end
				if index == nil then
					stringMap[#stringMap + 1] = v
					index = #stringMap
				end
				attString = attString .. Write.ShortInt(index)
			else
				attString = attString .. Write[attributeType](v)
			end
		end
		str = str .. attString .. StringConversion.NumberToString(0, 1)
		return str, colorMap, stringMap
	end
end

local CreateInstanceWriter = function(properties)
	local WriteInstance = function(object, Write, colorMap, stringMap)
		local str = ""
		for i, v in pairs(properties) do
			local value
			if v[1] == "MeshId" and object.ClassName == "UnionOperation" then
				value = object:GetAttribute("MeshId")
			else
				value = object[v[1]]
			end
			local valueType = v[2]
			local defaultValue = v[3]
			if (valueType == "Color3") and (value ~= defaultValue) then
				local index = nil
				for i, v in pairs(colorMap) do
					if v == value then
						index = i
						continue
					end
				end
				if index == nil then
					colorMap[#colorMap + 1] = value
					index = #colorMap
				end
				str = str .. StringConversion.NumberToString(i, 1)
				str = str .. Write.ShortInt(index)
				continue
			elseif (valueType == "String") and (value ~= defaultValue) then
				local index = nil
				for i, v in pairs(stringMap) do
					if v == value then
						index = i
						continue
					end
				end
				if index == nil then
					stringMap[#stringMap + 1] = value
					index = #stringMap
				end
				str = str .. StringConversion.NumberToString(i, 1)
				str = str .. Write.ShortInt(index)
				continue
			elseif value ~= defaultValue then
				str = str .. StringConversion.NumberToString(i, 1)
				str = str .. Write[valueType](value)
			end
		end

		str = str .. StringConversion.NumberToString(0, 1)
		return str, colorMap, stringMap
	end
	return WriteInstance
end

local WriteInstance

WriteInstance = {
	Model = WithAttributes(CreateInstanceWriter(InstanceProperties.Model)),
	Folder = WithAttributes(CreateInstanceWriter(InstanceProperties.Folder)),
	Part = WithAttributes(CreateInstanceWriter(InstanceProperties.Part)),
	PartNoAttributes = CreateInstanceWriter(InstanceProperties.Part),
	BoolValue = WithAttributes(CreateInstanceWriter(InstanceProperties.BoolValue)),
	WedgePart = CreateInstanceWriter(InstanceProperties.WedgePart),
	StringValue = CreateInstanceWriter(InstanceProperties.StringValue),
	MeshPart = WithAttributes(CreateInstanceWriter(InstanceProperties.MeshPart)),
	UnionOperation = WithAttributes(CreateInstanceWriter(InstanceProperties.UnionOperation)),
	Texture = CreateInstanceWriter(InstanceProperties.Texture),
	BlockMesh = CreateInstanceWriter(InstanceProperties.BlockMesh),
	PointLight = CreateInstanceWriter(InstanceProperties.PointLight),
	SpotLight = CreateInstanceWriter(InstanceProperties.SpotLight),
	SurfaceLight = CreateInstanceWriter(InstanceProperties.SurfaceLight),
	SpecialMesh = CreateInstanceWriter(InstanceProperties.SpecialMesh),
	Decal = CreateInstanceWriter(InstanceProperties.Decal),
	Fire = CreateInstanceWriter(InstanceProperties.Fire),
	Smoke = CreateInstanceWriter(InstanceProperties.Smoke),
	Attachment = CreateInstanceWriter(InstanceProperties.Attachment),
}

return WriteInstance]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>
